<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[代码托管平台码云(Gitee)到Gitea迁移记]]></title>
    <url>%2F2020%2F03%2F01%2FGitee2Gitea%2F</url>
    <content type="text"><![CDATA[团队的代码托管管理平台之前一直用Gitee的企业版本，但除了代码pull/push操作外，基本不用平台上其它功能，除了要新建一个仓库要打开下网页版，其它时间基本不会访问网页版本，所以经过半天的调研，从GitLab/Gogs/Gitea中选择了Gitea，把迁移过程记录如下。 安装Gitea因为服务器上刚好装有docker，按照官方文档选择了最简单的docker安装。 12345docker pull gitea/gitea:latestsudo mkdir -p /data/giteadocker run -d --name=gitea -p 10022:22 -p 10080:3000 -v /data/gitea:/data gitea/gitea:latest// 重启giteadocker restart gitea 安装完成后遇到了页面有三个静态文件（css/js）加载不成功，导致页面排版混乱，F12查看控制台报错net::ERR_CONTENT_LENGTH_MISMATCH，google之，找到这篇文章 Nginx 做代理时浏览器报错 net::ERR_CONTENT_LENGTH_MISMATCH，按照此方法解决。 配置Nginx在服务器Nginx上配置反向代理 vi /etc/nginx/conf.d/gitea.conf 1234567891011121314upstream gitea &#123; server 127.0.0.1:10080; keepalive 2000;&#125;server &#123; listen 80; server_name git.i.example.com; client_max_body_size 1024M; location / &#123; proxy_pass http://gitea/; proxy_set_header Host $host:$server_port; &#125;&#125; 重新加载配置 1sudo nginx -s reload 域名解析git.i.example.com解析到当前服务器ip，并把服务器防火墙入方向的10022 tcp端口打开，以便使用ssh方式clone仓库时使用。 Gitea初始化打开http://.i.example.com，进入初始化界面（如果没进随便点注册或登录就会进），除了数据库根据需要配置，几个域名和网址要修改下，邮箱和其它选项按需配置。以后如果想修改配置，可以直接修改/data/gitea/gitea/conf/app.ini文件配置说明，修改完成后重启下gitea即可生效。 仓库迁移因为我迁移的是团队项目，所以先通过Gitea提供的API把所有仓库以镜像方式（镜像方式同步过来仓库对成员为只读，并且可以设置间隔时间，默认8小时，定时从原始地址Gitee同步最新代码）同步过来[操作1]，然后为每个项目配置好协作者/团队/权限等设置，在这期间，团队成员还是往Gitee上提交代码，待全部设置完成后取消告知团队成员不要往Gitee提交代码，并调用Giea api把所有仓库从Gitee上同步一下最新代码[操作2]，然后每个仓库从镜像仓库转为普通仓库，并让团队的所有在自己仓库根目录执行修改本地仓库Git远程仓库地址替换操作[操作3] [操作1]：登录Gitea后，界面右上角有一个加号，点开了后有一个迁移外部仓库的功能，只要填入外部仓库URL，授权验证信息等信息就可以一键把外部仓库的所有代码（包括所有branch和commit）迁移到Gitea，如果要迁移的仓库比较多，可以使用Gitea提供的Api来操作。对应此迁移操作的api是 1234567891011121314151617181920POST /repos/migrate?access_token=&lt;your gitea admin access token&gt;Request body&#123; description: MigrateRepoForm form for migrating repository auth_password: string auth_username: string clone_addr*: string description: string issues: boolean labels: boolean milestones: boolean mirror: boolean private: boolean pull_requests: boolean releases: boolean repo_name*: string uid*: integer($int64) wiki: boolean&#125; 注： access_token 请在有管理员权限的账号的设置&gt;应用中创建； Request body 中的uid即管理后台&gt;账户管理/组织管理中的ID列值； 找了Gitee没找到可以获取账户下所有仓库信息的API，所以只好手写了一个Gitee仓库地址的文件，类似 vi gitee-url.txt 12https://gitee.com/example/project_a.githttps://gitee.com/example/project_b.git 使用shell脚本逐行读取url，并调用Gitea api迁移仓库。 12345678910#!/bin/bashfor line in $(&lt;gitee-url.txt);do # Windows注释下面这行 line=$(echo $line | sed -e 's/\r//g'); tmp=$&#123;line#https://gitee.com/xxx/&#125;; project_name=$&#123;tmp%.git&#125;; curl -X POST "http://git.i.example.com/api/v1/repos/migrate?access_token=&lt;your gitea admin access token&gt;" -H "accept: application/json" -H "Content-Type: application/json" -d "&#123; \"auth_password\": \"NDY2&amp;F*K!hL75y*z\", \"auth_username\": \"korvin101@gmail.com\", \"clone_addr\": \"$line\", \"issues\": true, \"labels\": true, \"milestones\": true, \"mirror\": true, \"private\": true, \"pull_requests\": true, \"releases\": true, \"repo_name\": \"$project_name\", \"uid\": 2, \"wiki\": true&#125;";done [操作2]：从Gitee上同步最新代码 1234567for line in $(&lt;gitee-url.txt);do line=$(echo $line | sed -e 's/\r//g'); tmp=$&#123;line#https://gitee.com/xxx/&#125;; project_name=$&#123;tmp%.git&#125;; curl -X POST "http://git.i.example.com/api/v1/repos/&#123;owner&#125;/$project_name/mirror-sync?access_token=&lt;your gitea admin access token&gt;" -H "accept: application/json"done 注：owner为项目拥有者用户名/组织名 [操作3]：原本地仓库Git远程仓库地址替换 123456789101112131415// http地址// 原代码仓库http地址：https://gitee.com/example/project_a.git// 新代码仓库http地址：http://git.i.example.com/JIANSU/project_a.git// https://gitee.com/example &gt; http://git.i.example.com/JIANSU// 本地仓库使用此命令替换，可在包含所有项目的外层文件夹路径下执行批量替换// Windows删除'.bak'sed -i '.bak' 's/https:\/\/gitee\.com\/example/http:\/\/git\.i\.example.com\/JIANSU/g' */.git/config// ssh地址// 原代码仓库ssh地址：git@gitee.com:example/project_a.git// 新代码仓库地址：ssh://git@git.i.example.com:10022/JIANSU/project_a.git// git@gitee.com:example &gt; ssh://git@git.i.example.com:10022/JIANSU// 本地仓库使用此命令替换，可在包含所有项目的外层文件夹路径下执行批量替换// Windows删除'.bak'sed -i '.bak' 's/git@gitee\.com:example/ssh:\/\/git@git\.i\.example\.com:10022\/JIANSU/g' */.git/config 如果之前是用http地址进行克隆的仓库的话，现在就是在进行pull和push操作时，把账户密码换成Gitea的就可以了； 如果以前是用ssh克隆的仓库的话，现在在Gitea的设置&gt;SSH / GPG 密钥里添加一下公钥就可以进行git pull/git push等操作了； 仓库备份Gitea有自己的备份与恢复功能备份与恢复，这个备份比较全面，数据/代码/日志都可以备份，正是因为这样，如果仓库比较多这个备份的文件肯定会有点大，而且每次都是全量备份，所以频率肯定不能太高，而我只是想对仓库代码做一个高频率备份，所以写了一个Python3脚本调用Gitea api和 Git命令来进行所有仓库的所有分支代码备份，因为这个备份基于Git机制，所以虽然频率高，但备份始终只有一份。脚本如下： backup.py 如果使用python2运行，分支名里有中文的话，请自行处理字符编码问题。 ** python123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#!/usr/bin/python3import osimport platformimport requestscurrent_dir = os.path.abspath(os.path.dirname(__file__))access_token = "&lt;your access token&gt;"repos_url = 'http://git.i.example.com/api/v1/repos/search?access_token=&#123;&#125;&amp;page=&#123;&#125;&amp;limit=&#123;&#125;'branches_url = 'http://git.i.example.com/api/v1/repos/&#123;&#125;/branches?access_token=&#123;&#125;'repo_key_url = 'http://git.i.example.com/api/v1/repos/&#123;&#125;/&#123;&#125;/keys?access_token=&#123;&#125;'def repos(): page = 1 limit = 50 has_next = True while has_next: r = requests.get(repos_url.format(access_token, page, limit)) for repo in r.json()['data']: yield repo page += 1 has_next = len(r.json()['data']) == limit"""拉取项目所有分支代码到本地"""def sync_repo(): repo_index = 0 for repo in repos(): repo_index += 1 # 克隆仓库 os.chdir(current_dir) print('克隆第 &#123;&#125; 个仓库 &#123;&#125; '.format(repo_index, repo['name'])) os.system("git clone &#123;&#125;".format(repo['ssh_url'])) os.chdir(os.path.join(current_dir, repo['name'])) # 更新仓库 print('同步 &#123;&#125; 仓库所有分支'.format(repo['name'])) os.system('git fetch --all') # if platform.system() == 'Windows': # Windows branches = requests.get(branches_url.format( repo['full_name'], access_token)).json() for branch in branches: branch_name = branch['name'] os.system('git branch --track &#123;&#125; origin/&#123;&#125;'.format(branch_name, branch_name)) # 用reset而不用pull是因为如果分支被强推了pull下来会有合并冲突，用rest就不会有冲突问题 os.system('git checkout &#123;&#125; &amp;&amp; git reset --hard origin/&#123;&#125;'.format(branch_name, branch_name)) # else: # # Linux/macOS # # git branch -r | grep -v '\-&gt;' | while read remote; do git branch --track $&#123;remote#origin/&#125; $remote; done &amp;&amp; git fetch --all &amp;&amp; git pull --all # # os.system("git branch -r | grep -v '\-&gt;' | while read remote; do git branch --track $&#123;remote#origin/&#125; $remote; done &amp;&amp; git fetch --all &amp;&amp; git pull --all") # # # 用reset而不用pull是因为如果分支被强推了pull下来会有合并冲突，用rest就不会有冲突问题 # os.system("git branch -r | grep -v '\-&gt;' | while read remote; do git branch --track $&#123;remote#origin/&#125; $remote; git checkout $&#123;remote#origin/&#125;; git reset --hard $remote; done")"""设置项目部署公钥"""def set_pub_key(): repo_index = 0 body = &#123; "key": "ssh-rsa aabbcc", "read_only": True, "title": "SandBox" &#125; for repo in repos(): repo_index += 1 print('===&#123;&#125;. &#123;&#125;==='.format(repo_index, repo['name'])) r = requests.post(repo_key_url.format( repo['owner']['username'], repo['name'], access_token), data=body) print(r.json())if __name__ == '__main__': sync_repo() # set_pub_key() 可以把脚本放在本地，使用cron(Linux/macOS)/计划任务(Windows)定时运行python backup.py Windows计划任务运行cmd命令时，可使用非当前登录用户运行，这样就不会弹出小黑窗。]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Git</tag>
        <tag>Gitee</tag>
        <tag>GitLab</tag>
        <tag>Gite</tag>
        <tag>Gogs</tag>
        <tag>迁移</tag>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebFlux中mongo操作-Transaction]]></title>
    <url>%2F2020%2F01%2F17%2FWebFlux%E4%B8%ADmongo%E6%93%8D%E4%BD%9C-Transaction%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132@PostMapping("/test")public Mono testA(@RequestParam boolean exception) &#123; return embedService.saveAC(new ADocument("张三"), new CDocument("李四"), exception);&#125;@Overridepublic Mono&lt;Boolean&gt; saveAC(ADocument aDocument, CDocument cDocument, boolean exception) &#123; return reactiveMongoTemplate.inTransaction() //所有文档的持久化操作都只能在单独一个execute函数中汇总实现 .execute(action -&gt; action.insert(aDocument) .flatMap(a -&gt; &#123; cDocument.setName(a.getName() + "copy"); return action.insert(cDocument) .map(d -&gt; &#123; if (exception) &#123; //测试跨文档的异常回滚 throw Exceptions.propagate(new RuntimeException("模拟异常的出现")); &#125; return d; &#125;); &#125;) ) //如果里面是个mono，则用next取出第一个元素就是里面的mono .next() .map(list -&gt; &#123; //需要注意，在execute之外的函数中产生的异常，不会触发事务的回滚。 // if (exception) &#123; // throw Exceptions.propagate(new RuntimeException("模拟异常的出现")); // &#125; return Boolean.TRUE; &#125;);&#125; flux的数据库操作，在有事务的前提下不能用flatMap，要用事务不能用flatMap要用concatMap保持有序 12345678910111213141516171819202122232425262728293031323334@PostMapping("/test")public Mono testA(@RequestParam boolean exception) &#123; return embedService.saveAC(new ADocument("张三"), new CDocument("李四"), exception);&#125;@Overridepublic Mono&lt;Boolean&gt; saveAC(ADocument aDocument, CDocument cDocument, boolean exception) &#123; return reactiveMongoTemplate.inTransaction() //所有文档的持久化操作都只能在单独一个execute函数中汇总实现 .execute(action -&gt; Flux.fromIterable("1", "2", "3") //如果是个flux此处要用concatMap保持有序不能用flatMap .concatMap(i -&gt; action.insert(aDocument) .flatMap(a -&gt; &#123; cDocument.setName(a.getName() + "copy"); return action.insert(cDocument) .map(d -&gt; &#123; if (exception) &#123; //测试跨文档的异常回滚 throw Exceptions.propagate(new RuntimeException("模拟异常的出现")); &#125; return d; &#125;); &#125;)); ) //如果里面返回的就是一个flux则不需要使用next //.next() .map(list -&gt; &#123; //需要注意，在execute之外的函数中产生的异常，不会触发事务的回滚。 // if (exception) &#123; // throw Exceptions.propagate(new RuntimeException("模拟异常的出现")); // &#125; return Boolean.TRUE; &#125;);&#125;]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Reactive</tag>
        <tag>事务</tag>
        <tag>mongo</tag>
        <tag>数据库</tag>
        <tag>Flux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebFlux中mongo操作-Aggregation]]></title>
    <url>%2F2020%2F01%2F17%2FWebFlux%E4%B8%ADmongo%E6%93%8D%E4%BD%9C-Aggregation%2F</url>
    <content type="text"><![CDATA[switch 12345678910111213ConditionalOperators.Switch.CaseOperator cond = ConditionalOperators.Switch.CaseOperator.when( BooleanOperators.And.and( ComparisonOperators.Eq.valueOf("channelBillStatus1").equalToValue("已结算"), ComparisonOperators.Eq.valueOf("channelBillStatus2").equalToValue("已结算") ) ).then("已结清"); Aggregation aggregation = Aggregation.newAggregation( Aggregation.project("channelBillStatus1", "channelBillStatus2") .and(ConditionalOperators.switchCases(cond).defaultTo("未结清")).as("channelBillStatus") ); reactiveMongoTemplate.aggregate(aggregation, PlatformBillItem.class, PlatformBillBo.class); lookup及id类型转换 123456789101112//把_id转成String并赋值给id Aggregation.project("internalId", "name", "isAvailable", "isCanAdd", "fitGender", "fitAge", "fitMaritalStatus", "price", "sortNo", "createdAt") //如果需要把String转Object使用ConvertOperators.ToObjectId.toObjectId() .and(ConvertOperators.ToString.toString("$_id")).as("id"); //用当前表的id值去匹配chn_section表的sectionId字段值，并把结果存入chnSections数组 Aggregation.lookup("chn_section", "id", "sectionId", "chnSections"); //如有需要，把chnSections数组拆出来，chnSections数组有几个元素，当前这条数据就会被拆成多少条，chnSections值会变成元素值而不再是原来的数组 //如果chnSections数组无值，默认会丢弃这条数据，如果要保留设置preserveNullAndEmptyArrays=true Aggregation.unwind("chnSection", true); //只输出这些字段 Aggregation.project("internalId", "name", "isAvailable", "isCanAdd", "fitGender", "fitAge", "fitMaritalStatus", "price", "sortNo", "createdAt", "chnSections"); reactiveMongoTemplate.aggregate(aggregation, PlatformBillItem.class, PlatformBillBo.class); 如果lookup时，如果要对匹配的数据进行筛选（参考链接：https://stackoverflow.com/questions/51107626/spring-data-mongodb-lookup-with-pipeline-aggregation） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//原始mongo//&#123;// $lookup:// &#123;// from: &lt;collection to join&gt;,// let: &#123; &lt;var_1&gt;: &lt;expression&gt;, …, &lt;var_n&gt;: &lt;expression&gt; &#125;,// pipeline: [ &lt;pipeline to execute on the collection to join&gt; ],// as: &lt;output array field&gt;// &#125;//&#125;//自定义一个AggregationOperation类public class CustomProjectAggregationOperation implements AggregationOperation &#123; private String jsonOperation; public CustomProjectAggregationOperation(String jsonOperation) &#123; this.jsonOperation = jsonOperation; &#125; @Override public Document toDocument(AggregationOperationContext aggregationOperationContext) &#123; return aggregationOperationContext.getMappedObject(Document.parse(jsonOperation)); &#125;&#125;private static String getJsonOperation() &#123; return "&#123;" + " $lookup: " + " &#123;" + " from: 'chn_set_meal'," + " let: &#123;" + " id: &#123; $toString: '$_id' &#125;" + " &#125;," + " pipeline: [" + " &#123;" + " $match: " + " &#123;" + " $expr: " + " &#123;" + " $and: " + " [" + " &#123;" + " $eq: ['$setMealId', '$$id']" + " &#125;," + " &#123;" + " $eq: ['$cooperationState', '合作中']" + " &#125;" + " ]" + " &#125;" + " &#125;" + " &#125;," + " &#123;" + " $project: &#123;" + " channelId: 1," + " channelName: 1" + " cooperationState: 1" + " &#125;" + " &#125;" + " ]," + " as: 'channels'" + " &#125;" + "&#125;&#125;"; &#125;AggregationOperation aggregationOperation = new CustomProjectAggregationOperation(getJsonOperation()); return reactiveMongoTemplate.aggregate(Aggregation.newAggregation(aggregationOperation), SetMeal.class, SetMealListBo.class); group 123456789101112131415//背景：查询交易表，订单和交易一对多Aggregation.group("orderNo") //单一组的金额汇总 .sum("amount").as("totalAmount") //组的最后一个订单号 .last("orderNo").as("orderNo") //组里数据条数 .count().as("tradeCount") //把一组数据里每条数据的状态放到一个statuses数组里 .addToSet("status").as("statuses") //把一组数据里的一些字段信息重新组装成一个对象放到billItems的对象数组里 .push(new BasicDBObject("tradeContent", "$tradeContent") .append("tradeNo", "$tradeNo") .append("amount", "$amount") ).as("billItems");]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Reactive</tag>
        <tag>事务</tag>
        <tag>mongo</tag>
        <tag>数据库</tag>
        <tag>Aggregation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自用软件推荐]]></title>
    <url>%2F2019%2F10%2F12%2Fawesome-software%2F</url>
    <content type="text"><![CDATA[日用软件/效率提升/开发工具/Chorme插件扩展推荐 应用日常 Alfred(macOS) Mac上的效率启动神器 uTools(macOS/Windows/Linux) 你的生产力工具集. uTools是一个极简、插件化、跨平台的现代桌面软件。通过自由选配丰富的插件，打造你得心应手的工具集合。 当你熟悉它后，能够为你节约大量时间，让你可以更加专注地改变世界。 除了插件中心提供的工具，随手就可以用自己熟悉的语言写一个简单的小工具放上面，感觉比Alfred还好用，哈哈 WGestures(Windows) 系统鼠标手势 Snipaste(macOS/Windows) 截图/贴图 Everything(Windows) Windows本地搜索，快如闪电，用过就回不去 Rolan(Windows) Windows上的快速启动器 Rime(macOS/Windows/Linux) 输入法 多台设备共用键鼠(macOS/Windows/Linux) 多台设备共用键鼠 [Shadowsocks/v2rayNG/v2ray](macOS/Windows/Linux/Android） 科学上网 AppCleaner(macOS） 应用卸载器 Typora(macOS/Windows/Linux） markdown笔记写作应用，配合坚果云或Dropbox同步，爽 SumatraPDF(Windows） PDF阅读器 EagleGet(Windows） 下载器 Free Download Manager(macOS/Windows） 下载器 Bandizip(macOS/Windows） 压缩/解压软件 eZip(macOS/Windows） 压缩/解压软件 reveal.js(Web） 程序员的PPT工具 Xnip(macOS） 截图应用 pap.er(macOS） 壁纸应用 aText(macOS/Windows） 文字输入效率提升工具 开发 Cmder(Windows) Windows默认命令行替代品 Insomnia(macOS/Windows/Linux) 跨平台的REST客户端 postman(macOS/Windows/Linux/Chrome App) 跨平台的接口调试工具，有mocks服务和接口文档生成功能 iTerm2(macOS) 终端应用 hyper(macOS/Windows/Linux) 漂亮的终端应用 Fiddler(macOS/Windows/Linux) 抓包工具 Charles(macOS/Windows/Linux) 抓包工具 frp(macOS/Windows/Linux) 内网穿透 Chrome扩展/应用 Adblock Plus 广告拦截器，谁用谁知道 Checker Plus for Gmail™ Gmail/Inbox插件，不用打开网页处理邮件 Dark Reader 黑色主题，适用于任何网站。关爱眼睛，就使用Dark Reader进行夜间和日间浏览 Extensity 扩展管理工具，快速的启用/禁用 Wappalyzer 探测当前网页正在使用的开源软件或者js类库 Ghostery 了解谁在跟踪您的网页浏览操作，并可禁用跟踪行为。 Google翻译 支付在网页中划词翻译 彩云小译 网页翻译插件 LastPass 密码管理 Tampermonkey 给网站添加自定义脚本 Stylish 给网站添加自定义样式表 Web Server for Chrome 快速搭建本地Web服务器(当然，你也可以python -m http.server) Octotree 在浏览器左侧树形展示Github代码。 Prism Pretty 美化代码（html、css、js、json……） Proxy SwitchyOmega 你懂的 v2ex plus 优雅便捷的 V2EX 扩展 Toby for Chrome 标签页管理/稍后阅读/资料归档分类… Web Scraper 图形化创建爬虫，爬取网站数据 惠惠购物助手/购物党自动比价工具 在主流电商网站页面上提供商品的历史价格，及在同款商品在其它平台的价格比较。 Google Keep 记事和清单]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>效率</tag>
        <tag>软件</tag>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(猫)花木兰领养注意事项]]></title>
    <url>%2F2019%2F09%2F17%2Fadoption-cat-Hua-Mulan%2F</url>
    <content type="text"><![CDATA[成为猫奴前的准备 领养前请确认能否接受以下几点，如果否，不建议领养 养猫请不要半途而废，请不要让它变成流浪猫相对于狗来说，猫掉毛很严重，房间经常要打扫，衣服每天都要用粘毛器粘毛猫不像狗一样会听你的指令，绝大部分听不懂猫每年要驱虫和打狂犬费用几百猫如果生病去看病花费要比人生病花费大很多很多绝育需要花费1~2k猫会比较粘人，一般喜欢在人腿上或身上睡觉猫呆的房间不能开窗小猫信息 生日：2018年09月23日性别：妹子品种：英短银渐层+虎斑，有部分折耳基因家族：爷爷：英短银渐层奶奶：美短虎斑爸爸：美短虎斑妈妈：英短银渐层（有折耳基因）新家 1．刚带回家应该先放到猫砂里，拿它的爪子刨几 猫砂，让它知道那里是拉屎撒尿的地方，最好让小猫在里面待一会儿2．如果小猫在其他地方拉屎撒尿了，把排泄物处理掉放到猫砂里去，让后把小猫也放到猫砂里，小猫闻到那气味让它知道应该在猫砂里厕所，然后用的爪子刨猫砂把排泄物盖起来吃 主食一定是猫粮，猫粮选购请自己网上查询，这里不提供建议不能喝生水最好倒是温水，凉开水也可以，猫喝的水每天换一次猫粮倒碗里小猫自己会吃，不要太多也不要太少，一天的量就可以，太多了过夜不新鲜猫可能就不喜欢吃了10个月内都可以吃幼猫粮，后面可以换成成猫 粮，除了猫粮，也要给猫些吃湿粮、猫罐头、营养膏和其他猫零食，但不要给给猫吃太多，因为这些食物比较香，如果猫吃多了，可能就会挑食不喜欢吃猫粮了平时也可以买点鸡胸肉，用清水煮熟，然后撕下 来喂猫吃。尽量别给猫吃咸的东西或其它味道的人吃的东西目前小猫已经可以不用喝奶了，不要给猫喝牛奶，牛奶里有乳糖，猫是不能消化乳糖的，如果喝了可能会腹泻，严重会致死其他东西给猫吃之前先网上查下能不能给猫吃用 1．可以买个猫抓盘或猫抓板猫喜欢到处抓东西，如果有纸箱子猫也会经常抓2．可以买个猫爬架，让猫玩，猫喜欢爬高高3．猫到夏天可能会掉毛比较多，网上买个猫毛梳子 或噜猫手套时常给猫去去毛4．因为猫会掉毛，抱它玩了之后，衣服上经常会粘 上毛，可以淘宝买个粘毛滚筒粘衣服上或是其它地方的猫毛，十分有效玩 可以买激光笔啊，逗猫棒之类的猫玩具，让小猫玩洗澡 可以自己在家洗（容易被抓伤）或是带去宠物店（100多一次）绝育 请在适当的时候带猫去做绝育疫苗 猫的狂犬和驱虫每年要打，人的狂犬疫苗自己决定要不要打，不提供建议其它注意事项 前面说了，猫喜欢爬高高，所以猫能够跳上去或爬上去的窗户阳台要关掉，猫不知道高空危险，会跳楼的，很多猫都是坠楼死掉的]]></content>
      <categories>
        <category>猫</category>
      </categories>
      <tags>
        <tag>猫</tag>
        <tag>Cat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git后悔药]]></title>
    <url>%2F2019%2F07%2F25%2Fgit-reset%2F</url>
    <content type="text"><![CDATA[使用git提交代码过程中有时会手抖提交错误代码，这时就需要用到git的后悔药reset操作。 差异（diff）工作区vs暂存区: git diff 暂存区vs本地仓库: git diff —cached 本地仓库vs远程仓库: git diff &lt;分支名&gt; origin/&lt;分支名&gt; 撤消（reset）撤消工作区修改: git reset —hard 撤消(1)git add: git reset &amp;&amp; git checkout .或git reset —hard(会还原所有修改) 撤消(2) git commit: git reset --hard origin/master(使用远端的master分支恢复到本地) 撤消(3) git push: git reset --hard HEAD^ &amp;&amp; git push -f(先在本地回到上一个版本，然后强推到远端)title: git reset participant 工作区 participant 暂存区 participant 本地仓库 participant 远程仓库 工作区->暂存区:(1) git add 暂存区->本地仓库:(2) git commit 本地仓库->远程仓库:(3) git push{"theme":"simple"} var code = document.getElementById("sequence-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value)); var diagram = Diagram.parse(code); diagram.drawSVG("sequence-0", options);]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>reset</tag>
        <tag>恢复</tag>
        <tag>后悔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令别名设置]]></title>
    <url>%2F2019%2F06%2F28%2Fgit-alias%2F</url>
    <content type="text"><![CDATA[如果平时使用git使用git命令多于GUI工具，则设置一些常用命令的别名有且于效率提升，以下是我平时使用较多的一些命令的别名设置 Git别名设置 123456789git config --global alias.co checkoutgit config --global alias.ci commitgit config --global alias.br branchgit config --global alias.cp cherry-pickgit config --global alias.unstage 'reset HEAD'# 可用git pull -r代替git config --global alias.fr '!f() &#123; git fetch &amp;&amp; git rebase $@; &#125;; f'; # git提交日志git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset - %Cgreen(%cd)%C(yellow)%d%Creset %s %C(blue)[%an/%cn]%Creset' --date=format:'%Y-%m-%d %H:%M:%S' --abbrev-commit" 删除别名 1git config --global --unset alias.xxx 以下两个命令设置git alias和zsh alias都失败，暂没找到方法可以设置别名 12# 查看仓库提交者排名前 5git log --pretty='%aN' | sort | uniq -c | sort -k1 -n -r | head -n 5 12# 统计每个人增删行数git log --format='%aN' | sort -u | while read name; do echo -en "$name\t"; git log --author="$name" --pretty=tformat: --numstat | awk '&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf "added lines: %s, removed lines: %s, total lines: %s\n", add, subs, loc &#125;' -; done git lg命令效果图]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android真机调试常用命令]]></title>
    <url>%2F2019%2F04%2F28%2Fandroid%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[使用USB连接Android真机调试时，使用无线连接调试会方便很多，并使用电脑端用adb命令实现截图和录屏，方便调试和问题反馈。 无线调试12345678910# 前提条件：手机和电脑处理同一网段# 第一次手机先使用USB连接电脑执行以下命令让手机上的某一端口处于监听状态adb tcpip &lt;port&gt;# 在手机上查看ip地址或使用以下命令查看ipadb shell ifconfig # 连接手机（在同一个环境下，一般手机/电脑不重启就会一直连接着）adb connect &lt;ip&gt; :&lt;port&gt;# 查看连接的设备adb devices 截图12# 截图并保存到手机sd卡的下adb shell screencap -p /sdcard/screenshot.png 便捷脚本（截图并自动复制到电脑剪切板/保存到电脑本地） 因脚本里调用了linux/macOS的命令，所以只适用于macOS系统，windows请自行修改脚本。 vi shot.sh 1234567891011121314151617181920#!/bin/bash# Android截图，定位和预览默认关闭，请取消注释dd=`date +%Y-%m-%d-%H-%M-%S`pwd=`pwd`adb shell screencap -p /sdcard/screenshot.pngadb pull /sdcard/screenshot.pngadb shell rm /sdcard/screenshot.pngmv screenshot.png $dd.pngecho &quot;截图已保存为当前目录下的&quot;$dd.png# 修改图片尺寸，长或宽最大不超过960，等比缩放echo &quot;压缩图片...&quot;sips -Z 960 $pwd/$dd.png# 定位到文件open ./$dd.png -R# 打开预览open -a Preview $dd.png# 复制到剪切板osascript -e &apos;on run args&apos; -e &apos;set the clipboard to POSIX file (first item of args)&apos; -e end $pwd/$dd.pngecho &quot;截图已复制到剪切板&quot; 授予执行权限1chmod a+x shot.sh 使用方法 1./shot.sh ⌘+v试试 可把命令添加alias别名 录屏1234567# 执行录屏并保存到手机sd卡目录下（默认时长180s）# 可配置参数# --time-limit: 录制时长，单位秒# --size: 分辨率，如1280*720，不指定默认使用手机的分辨率# --bit-rate: 视频的比特率，如6Mbps为6000000# --verbose: 命令行显示logadb shell screenrecord /sdcard/demo.mp4 便捷脚本（录屏并自动复制到电脑剪切板/保存到电脑本地） 因脚本里调用了linux/macOS的命令，所以只适用于macOS系统，windows请自行修改脚本。 vi record.sh 1234567891011121314#!/bin/bash# Android录屏dd=`date +%Y-%m-%d-%H-%M-%S`&quot;-$1s&quot;pwd=`pwd`adb shell screenrecord --time-limit $1 /sdcard/screenrecord.mp4adb pull /sdcard/screenrecord.mp4adb shell rm /sdcard/screenrecord.mp4mv screenrecord.mp4 $dd.mp4echo &quot;$1秒视频已保存为当前目录下的&quot;$dd.mp4# 定位到文件open ./$dd.mp4 -R# 复制到剪切板osascript -e &apos;on run args&apos; -e &apos;set the clipboard to POSIX file (first item of args)&apos; -e end $pwd/$dd.mp4echo &quot;$1秒视频已复制到剪切板&quot; 授予执行权限1chmod a+x record.sh 使用方法12# 3为录制秒数，可修改./record.sh 3]]></content>
      <categories>
        <category>程序员</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>macOS</tag>
        <tag>命令</tag>
        <tag>效率</tag>
        <tag>无线</tag>
        <tag>调试</tag>
        <tag>adb</tag>
        <tag>USB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS笔记]]></title>
    <url>%2F2019%2F04%2F24%2Fjs%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[js中要用变量作为key的话使用方括号括住例：this.searchKeyword123456this.$http(&#123; url: this.searchUrl, method: this.remoteRequestMethod, params: Object.assign(&#123;&#125;, this.searchParams, this.pager), data: Object.assign(&#123; [this.searchKeyword]: query &#125;, this.searchBody, this.pager) &#125;) 全文完🙈]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringWebFlux使用笔记]]></title>
    <url>%2F2019%2F02%2F28%2FSpringWebFlux%2F</url>
    <content type="text"><![CDATA[记录使用SpringWebFlux的一些笔记。 groupBy对flux进行分组。12345678910channelOnlineCityBoFlux.sort((s1, s2) -&gt; Objects.requireNonNull(s1.getInitial()).compareTo(s2.getInitial())) .groupBy(city -&gt; city.getInitial().substring(0, 1).toUpperCase()) .sort((s1, s2) -&gt; Objects.requireNonNull(s1.key()).compareTo(s2.key())) .flatMap(gf -&gt; gf.collectList() .map(cityList -&gt; &#123; ChannelOnlineCityGroupByPinYinBo cityGroupByPinYinBo = new ChannelOnlineCityGroupByPinYinBo(); cityGroupByPinYinBo.setLetter(gf.key()); cityGroupByPinYinBo.setCities(cityList); return cityGroupByPinYinBo; &#125;)); handlehandle作用相当于是filter和map的组合。]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Reactive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用alembic进行数据库版本管理]]></title>
    <url>%2F2018%2F09%2F13%2F%E4%BD%BF%E7%94%A8alembic%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[转自：https://www.cnblogs.com/blackmatrix/p/6236573.html，做了部分修改 前言随着项目业务需求的不断变更，数据库的表结构修改难以避免，此时就需要对数据库的修改加以记录和控制，便于项目的版本管理和随意的升级和降级。 Alembic 就可以很好的解决这个问题。Alembic 是 SQLAlchemy 作者开发的 Python 数据库版本管理工具。 安装1pip install alembic 通过 pip 命令安装，如果使用虚拟环境，记得激活虚拟环境后再执行 pip 命令 同时需要安装的还有 SQLAlchemy 和 PyMysql 12pip install sqlalchemypip install pymysql 初始化在使用 alembic 之前，需要进行初始化操作。 1alembic init &lt;YOUR_ALEMBIC_DIR&gt; YOUR_ALEMBIC_DIR，可以取一个符合项目名称规范的目录名，如 1alembic init alembic 此时需要注意，如果之前是在虚拟环境中安装的 alembic，需要激活虚拟环境后，在执行上述命令。 同时，建议 cd 到项目根目录再执行初始化操作，因为 YOUR_ALEMBIC_DIR 会在当前目录下创建。 显示类似结果即初始化成功。 12345678Creating directory D:\Project\py_sqlalchemy_demo\alembic ... doneCreating directory D:\Project\py_sqlalchemy_demo\alembic\versions ... doneGenerating D:\Project\py_sqlalchemy_demo\alembic.ini ... doneGenerating D:\Project\py_sqlalchemy_demo\alembic\env.py ... doneGenerating D:\Project\py_sqlalchemy_demo\alembic\README ... doneGenerating D:\Project\py_sqlalchemy_demo\alembic\script.py.mako ... donePlease edit configuration/connection/logging settings in 'D:\\Project\\py_sqlalchemy_demo\\alembic.ini' before proceeding. 初始化成功后，会在执行初始化命令的目录下，生成一个 alembic.ini 的配置文件，及一个 alembic 目录，目录名就是之前设置的 YOUR_ALEMBIC_DIR。 修改配置文件接下来对 alembic.ini 的信息进行修改。 主要修改的是配置文件中的数据库连接部分。 1sqlalchemy.url = driver://user:pass@localhost:port/dbname 将配置文件中，此部分替换成对应的数据库连接，这个数据库连接的写法是与 SQLAlchemy 创建 engine 时是一样的。 如我在 demo 中使用的是 SQLAlchemy 与 PyMysql，那数据库连接就是类似如下 1mysql+pymysql://demo_user:demo123456@127.0.0.1:3306/demo_db 修改 env.py除修改配置文件外，还需要对 YOUR_ALEMBIC_DIR 目录下的 env.py 文件进行修改。 在 env.py 中，将 target_metadata 设置成项目的 model，使 alembic 能获取到项目中 model 定义的信息。 将原先的 1target_metadata = None 修改成项目中的 model123456import osimport syssys.path.append(dirname(dirname(abspath(__file__))))from app import dbtarget_metadata = db.metadata 创建新版本用 alembic revision -m + 注释 创建数据库版本 1alembic revision --autogenerate -m "init db" 运行后，类似如下结果，即创建版本成功 1234INFO [alembic.runtime.migration] Context impl MySQLImpl.INFO [alembic.runtime.migration] Will assume non-transactional DDL.INFO [alembic.autogenerate.compare] Detected removed table 'user'Generating D:\Project\py_sqlalchemy_demo\alembic\versions\7b55b3d83158_create_tables.py ... done 每次修改过 SQLAlchemy 的 model，执行此命令即可创建对应的版本。 执行成功后，会在项目根目录下的 alembic/versions / 下生成的对应版本的 py 文件。命令规则是版本号 + 注释。(这个命名规则是在配置文件中定义的) 在每次创建新版本后，需要执行将数据库升级到新版本的命令，才能继续更新版本。 变更数据库在每次创建新版本后，需要执行将数据库升级到新版本的命令，才能继续更新版本 将数据库升级到最新版本 1alembic upgrade head 运行结果类似 1234(venv_win) D:\Project\py_sqlalchemy_demo&gt;alembic upgrade headINFO [alembic.runtime.migration] Context impl MySQLImpl.INFO [alembic.runtime.migration] Will assume non-transactional DDL.INFO [alembic.runtime.migration] Running upgrade 7b55b3d83158 -&gt; b034414f04cd, create tables02 其中，命令中的 head 和 base 特指最新版本和最初版本。当需要对数据库进行升级时，使用 upgrade，降级使用 downgrade。 将数据库降级到最初版本 1alembic downgrade base 将数据库降级到执行版本，使用 alembic downgrade + 版本号，不包含注释部分 1alembic downgrade &lt;version&gt; 如 1alembic downgrade 7b55b3d83158 运行结果 123INFO [alembic.runtime.migration] Context impl MySQLImpl.INFO [alembic.runtime.migration] Will assume non-transactional DDL.INFO [alembic.runtime.migration] Running downgrade b034414f04cd -&gt; 7b55b3d83158, create tables02 升级也是同样的道理，alembic upgrade + 版本号 离线更新（生成 sql 脚本）在某些不适合在线更新的情况，可以采用生成 sql 脚本的形式，进行离线更新： 1alembic upgrade &lt;version&gt; --sql &gt; migration.sql 如： 1alembic upgrade ae1027a6acf --sql &gt; migration.sql 从特定起始版本生成 sql 脚本： 1alembic upgrade &lt;vsersion&gt;:&lt;vsersion&gt; --sql &gt; migration.sql 如： 1alembic upgrade 1975ea83b712:ae1027a6acf --sql &gt; migration.sql 如果是数据库降级操作，把 upgrade 替换为 downgrade。 查询当前数据库版本号在对数据库进行升级或降级后，会在当前操作的数据库中新增一个表；alembic_version。 表中的 version_num 字段记录了当前的数据库版本号。 清除所有版本如果需要清除所有的版本，将 versions 删除掉，同时删除数据库的 alembic_version 表。 参考资料http://alembic.zzzcomputing.com/en/latest/tutorial.html http://www.codeweblog.com/%E5%B8%B8%E8%A7%81%E7%9A%84sqlalchemy%E5%88%97%E7%B1%BB%E5%9E%8B-%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9%E5%92%8C%E5%85%B3%E7%B3%BB%E9%80%89%E9%A1%B9/ http://blog.csdn.net/wenxuansoft/article/details/50242957]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django REST framework单元测试「Unit Testing」]]></title>
    <url>%2F2017%2F09%2F05%2Fdjango-rest-framework%E6%8E%A5%E5%8F%A3%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[settingsDjango运行单元测试时，会以settings里的数据库配置里的NAME新建一个以test_开关的临时数据库，并在测试结束后删除，默认的测试数据库会以当前的migrations文件来创建数据表并进行迁移，但如果migrations文件很多，每次运行时间将很久，所以可以跳过迁移，直接以当前Model结果来创建表以提升测试效率，如果想进一步加快测试时创建数据库的速度，可以使用SQLite数据库引擎，当使用SQLite数据库引擎时，测试将默认使用内存数据库。1234567891011121314151617181920TESTING = len(sys.argv) &gt; 1 and sys.argv[1] == 'test'if TESTING: # 当使用SQLite数据库引擎时，测试将默认使用内存数据库 DATABASES['default'] = &#123; 'ENGINE': 'django.db.backends.sqlite3', &#125; # 单元测试时, 跳过migrate, 极 的提升测试运 效率 # 具体可以查看 # https://simpleisbetterthancomplex.com/tips/2016/08/19/django-tip-12-disabl ing-migrations-to-speed-up-unit-tests.html # https://stackoverflow.com/questions/36487961/django-unit-testing-taking-a- very-long-time-to-create-test-database class DisableMigrations(object): def __contains__(self, item): return True def __getitem__(self, item): return "notmigrations" MIGRATION_MODULES = DisableMigrations() 示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# -*- coding: utf-8 -*-from __future__ import absolute_importfrom __future__ import unicode_literalsfrom rest_framework import statusfrom rest_framework.test import APITestCasefrom apps.account.models import Userfrom apps.account.tests.test_utils import TestCaseUtils__author__ = 'jeff'class UserAPITests(APITestCase, TestCaseUtils): # 初始数据加载，可使用manage.py dumpdata [app_label app_label app_label.Model]生成 # xml/yaml/json格式的数据 # 一般放在每个应用的fixtures目录下, 只需要填写json文件名即可，django会自动查找 # 此测试类运行结束后，会自动从数据库里销毁这份数据 # fixtures = ['user.json'] def setUp(self): # 在类里每个测试方法执行前会运行 # 在此方法执行前，django会运行以下操作 # 1. 重置数据库，数据库恢复到执行migrate后的状态 # 2. 加载fixtures数据 # 所以每个测试方法里对数据库的操作都是独立的，不会相互影响 kwargs = dict(mobile_phone='15999999999', password='111111') self.user = User.app_user_objects.create(**kwargs) def tearDown(self): # 在类里每个方法结束执行后会运行 pass @classmethod def setUpClass(cls): # 在类初始化时执行，必须调用super super(UserAPITests, cls).setUpClass() cls.token = '' @classmethod def tearDownClass(cls): # 在整个测试类运行结束时执行，必须调用super super(UserAPITests, cls).tearDownClass() def test_app_user_login_success(self): """APP用户登录接口成功情况""" # path使用硬编码，不要使用reverse反解析url，以便在修改url之后能及时发现接口地址变化，并通知接口使用人员 path = '/api/api-token-auth/' data = &#123;'mobile_phone': '15999999999', 'password': '111111'&#125; response = self.client.post(path, data) # response.data是字典对象 # response.content是json字符串对象 self.assertEquals(response.status_code, status.HTTP_200_OK, '登录接口返回状态码错误: 错误信息: &#123;&#125;'.format(response.content)) self.assertIn('token', response.data, '登录成功后无token返回') def test_app_user_login_with_error_pwd(self): path = '/api/api-token-auth/' data = &#123;'mobile_phone': '15999999999', 'password': '123456'&#125; response = self.client.post(path, data) self.assertEquals(response.status_code, status.HTTP_400_BAD_REQUEST) self.assertJSONEqual('&#123;"errors":["用户名或密码错误。"]&#125;', response.content) def test_get_app_user_profile_success(self): """成功获取app用户个人信息接口""" path = '/api/account/user/profile/' headers = self.get_headers(user=self.user) response = self.client.get(path, **headers) # 校验一些关键数据即可 # 如果是创建新数据，不仅要校验返回的状态码和数据， # 还需要到使用Django ORM去数据库查询数据是否创建成功 self.assertEqual(response.status_code, status.HTTP_200_OK) self.assertEqual(6, len(response.data)) self.assertIn('url', response.data) self.assertIn('mobile_phone', response.data) self.assertIn('avatar', response.data) self.assertIn('company_name', response.data) self.assertIn('username', response.data) self.assertIn('is_inviter', response.data) def test_get_app_user_profile_without_token(self): """不传token请求获取用户信息接口""" path = '/api/account/user/profile/' response = self.client.get(path) self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED) 断言123456789101112131415161718192021222324252627282930# 来自unittest.case.TestCaseassertFalse(expr, msg=None)assertTrue(expr, msg=None)assertEqual(first, second, msg=None)assertNotEqual(first, second, msg=None)assertAlmostEqual(first, second, places=None, msg=None, delta=None)assertNotAlmostEqual(first, second, places=None, msg=None, delta=None)assertSequenceEqual(seq1, seq2, msg=None, seq_type=None)assertListEqual(list1, list2, msg=None)assertTupleEqual(tuple1, tuple2, msg=None)assertSetEqual(set1, set2, msg=None)assertIn(member, container, msg=None)assertNotIn(member, container, msg=None)assertIs(expr1, expr2, msg=None)assertIsNot(expr1, expr2, msg=None)assertDictEqual(d1, d2, msg=None)assertDictContainsSubset(expected, actual, msg=None)assertItemsEqual(expected_seq, actual_seq, msg=None)assertMultiLineEqual(first, second, msg=None)assertLess(a, b, msg=None)assertLessEqual(a, b, msg=None)assertGreater(a, b, msg=None)assertGreaterEqual(a, b, msg=None)assertIsNone(obj, msg=None)assertIsInstance(obj, cls, msg=None)assertNotIsInstance(obj, cls, msg=None)assertRaisesRegexp(expected_exception, expected_regexp, callable_obj=None, *args, **kwargs)assertRegexpMatches(text, expected_regexp, msg=None)assertNotRegexpMatches(text, unexpected_regexp, msg=None) 测试接口地址测试接口地址建议使用硬编码，不要使用reverse反解析url，原因是接口地址尽量避免改变，如果必须修改，需要以很明显的方式来提醒开发人员以便开发人员通知接口使用人员。 测试数据准备有如下两种方法准备测试数据 简单的数据可以在setUp()里来创建； 复杂数据可以使用fixtures来写，并在赋值给测试类的fixtures属性；fixtures数据示例123456789101112131415161718[ &#123; "model": "myapp.person", "pk": 1, "fields": &#123; "first_name": "John", "last_name": "Lennon" &#125; &#125;, &#123; "model": "myapp.person", "pk": 2, "fields": &#123; "first_name": "Paul", "last_name": "McCartney" &#125; &#125;] 测试覆盖率（coverage）在Pycharm里可以通用右键项目，选择Run &#39;Test:&#39; with Coverage来查看测试的覆盖率。也可以通过其它第三方包查看测试覆盖率，具体请自己查询。]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>restful api</tag>
        <tag>接口</tag>
        <tag>单元测试</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在macOS上更改Jenkins的默认用户，解决权限问题]]></title>
    <url>%2F2017%2F08%2F24%2F%E5%9C%A8macos%E4%B8%8A%E6%9B%B4%E6%94%B9jenkins%E9%BB%98%E8%AE%A4%E7%94%A8%E6%88%B7%E8%A7%A3%E5%86%B3%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在MacOS上使用dmg安装包安装完Jenkins之后，发了Jenkins自动在系统里新建了一个名为jenkins的用户。默认的，Jenkins程序里的自动化构建操作都是以这个用户身份来进行的，所以有时会出现一些权限问题，解决方法就是修改Jenkins配置文件，把Jenkins运行的默认账户改成平时用的账户。 12345678910111213#停止Jenkinssudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist# 修改Group和User# &lt;用户名&gt;填写你的MacOS用户名，不知道的可以在命令行使用whoami查看，不需要尖括号$ sudo vim +1 +/daemon +’s/daemon/staff/’ +/daemon +’s/daemon/&lt;用户名&gt; +wq org.jenkins-ci.plist# 可能相应文件夹的权限sudo chown -R &lt;用户名&gt;:staff /Users/Shared/Jenkins/sudo chown -R &lt;用户名&gt;:staff /var/log/jenkins/# 启动Jenkinssudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>Jenkins</tag>
        <tag>权限</tag>
        <tag>用户</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网穿透工具frp客户端自定义子域名访问配置]]></title>
    <url>%2F2017%2F08%2F16%2F%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7frp%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%90%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前提A: 公网电脑B: 内网电脑 下载从releases)下载系统对应的压缩包，Mac可使用darwin amd64的包，在公网电脑和本地电脑各放一份。 配置公网电脑上frps.ini1234567891011121314151617[common]# 用于接收 frpc 连接的端口bind_port = 7000# 通过此端口访问http服务vhost_http_port = 8080# 日志文件输出位置log_file = ./frps.log# 日志等级log_level = info# 域名subdomain_host = example.com# frp管理后台端口dashboard_port = 7500# frp管理后台用户名dashboard_user = admin# frp管理后台密码dashboard_pwd = admin 本地电脑上frpc.ini123456789101112[common]# 公网电脑IPserver_addr = 111.111.111.111# frp连接的端口server_port = 7000[web]type = http# 本地http服务端口local_port = 8080# 子域名前缀, 子域名前缀里不要使用下划线&quot;_&quot;，不然可能会出现莫名其妙的400错误可以用&quot;-&quot;代替。subdomain = iblogc 配置域名example.com的A记录的泛解析*.example.com指向公网电脑IP111.111.111.111 运行 在内网电脑B上8080端口运行http服务 在公网电脑上运行（Windows电脑上运行请去掉./） 1./frps -c ./frps.ini 在本地电脑上运行（Windows电脑上运行请去掉./） 1./frpc -c ./frpc.ini 成功在任何一台能联网的机器上访问 http://iblogc.example.com:8080 即可访问内网电脑B上的http服务。在任务一台能联网的机器上访问111.111.111.111:7500即可访问frp的管理后台。 frps服务端与nginx可共用80端口1234567891011server &#123; listen 80; server_name *.example.com; location / &#123; proxy_pass http://127.0.0.1:8080; proxy_redirect http://$host/ http://$http_host/; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; &#125;&#125;]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS远程连接Windows]]></title>
    <url>%2F2017%2F08%2F08%2Fmac%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5windows%2F</url>
    <content type="text"><![CDATA[MacOS连接Windows时，除了在Windows上打开远程桌面功能外，还需要修改Windows的组策略才能成功连接。 开始-运行-gpedit.msc，进入组策略编辑器。 在左侧边栏中展开，计算机配置-管理模板-Windows组件-远程桌面服务-远程桌面会话主机-安全，修改以下两项。 远程（RDP）连接要求使用指定的安全层，改为启用，安全层选择RDP。 要求使用网络级别的身份验证对远程连接的用户进行身份验证，改为禁用。 关闭组策略编辑器，重试远程，如果不行重启Windows再重试远程即可。]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>远程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django Rest framework入门笔记及跳坑记录]]></title>
    <url>%2F2016%2F12%2F17%2Fdjango-rest-framework%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%E5%8F%8A%E8%B7%B3%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[更新记录2016-01-26 初稿 序列化时嵌套显示外键关联字段 自动使用depth参数指定外键深度 手动指定使用外键对应model的小写为属性，外键对应的model序列化程序为值以下例子在HospitalPic序列化结果里嵌套显示Hospitalmodels.py 1234567from django.db import modelsclass Hospital(models.Model): name = models.CharField() class HospitalPic(models.Model): hospital = models.ForeignKey(Hospital) serializers.py 1234567891011121314from rest_framework import serializersclass HospitalSerializer(serializers.HyperlinkedModelSerializer): class Meta: model = Hospital fields = '__all__' class HospitalPicSerializer(serializers.HyperlinkedModelSerializer): hospital = HospitalSerializer() class Meta: model = HospitalPic fields = '__all__' 反向关系嵌套在Hospital序列化结果里嵌套显示HospitalPicserializers.py 12345678910111213from rest_framework import serializersclass HospitalPicSerializer(serializers.HyperlinkedModelSerializer): class Meta: model = HospitalPic fields = '__all__'class HospitalSerializer(serializers.HyperlinkedModelSerializer): hospitalpic_set = HospitalPicSerializer(many=Ture) class Meta: model = Hospital fields = '__all__' 在序列化对象里添加关联表的字段内容定义一个serializer Field，并添加参数source指向外键对对应的字段（source值其实是从当前序列化的实例的属性）1my_address= serializers.ReadOnlyField(source='address.full_address') 在序列化对象里添加自定义内容123456789101112from django.contrib.auth.models import Userfrom django.utils.timezone import nowfrom rest_framework import serializers class UserSerializer(serializers.ModelSerializer): days_since_joined = serializers.SerializerMethodField() class Meta: model = User def get_days_since_joined(self, obj): return (now() - obj.date_joined).days 使用ViewSet，并不有设置queryset，而是重写了get_queryset时，需要在router里增加base_name参数（base_name为router为ViewSet注册url时自动添加的name前缀，如果未设置则从ViewSet的queryset里取，使用ViewSet自动生成的url name为&lt;base_name&gt;-list &lt;base_name&gt;-detail 等）views.py123456class ContactViewSet(viewsets.ModelViewSet): serializer_class = ContactSerializer permission_classes = (permissions.IsAuthenticated,) def get_queryset(self): return self.request.user.contact_set.all() urls.py1router.register(r'contact', ContactViewSet, base_name='contact') 未设置base_name会报下面错误1&apos;base_name&apos; argument not specified, and could not automatically determine the name from the viewset, as it does not have a &apos;.queryset&apos; attribute. 给api接口的url添加了命名空间namespaceurls.py1url(r'^api/', include(router.urls, namespace='api')), 需要对HyperlinkedRelatedField字段的参数进行修改serializers.py12345678class HospitalPicSerializer(serializers.HyperlinkedModelSerializer): class Meta: model = HospitalPic fields = '__all__' extra_kwargs = &#123; 'url': &#123;'view_name': 'api:hospitalpic-detail'&#125;, 'hospital': &#123;'view_name': 'api:hospital-detail'&#125; &#125; 不然会出现以下错误1Could not resolve URL for hyperlinked relationship using view name "user-detail". You may have failed to include the related model in your API, or incorrectly configured the `lookup_field` attribute on this field. 不过话说我们全api的url加namespace一般是为了版本控制，所以有一种简单的方法,只要在settings.py添加基于namespace的版本控制，这样就不需要修改HyperlinkedRelatedField字段的view_name了urls.py12url(r'^api/v1/', include(router.urls, namespace='v1')),url(r'^api/v2/', include(router.urls, namespace='v2')), settings.py12345REST_FRAMEWORK = &#123; …… 'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.NamespaceVersioning', ……&#125; 要drf的错误提示为中文，需要设置1LANGUAGE_CODE = 'zh-CN' 如果设置为1LANGUAGE_CODE = 'zh-Hans' 虽然django默认表单错误会输出中文，但drf还是输出英文 django的validators可以直接在drf中使用，不需要做任何修改当字段里的属性editable=False时，ModelSerializer里该字段会抛弃model里显式和隐式（unique）的所有validatorsSerializer里write_only写在field里和写在extra_kwargs里是有区别的，123456789101112131415161718192021222324252627282930313233343536373839class UserRegisterSerializer(serializers.ModelSerializer): """用户注册Serializer""" code = serializers.CharField(min_length=4, max_length=6, label=_('验证码'), help_text=_('验证码'), write_only=True) re_password = serializers.CharField(label=_('重复密码'), help_text=_('重复密码'), validators=validators.password_validators(), write_only=True) class Meta: model = User fields = ('mobile_phone', 'code', 'password', 're_password') extra_kwargs = &#123;'password': &#123;'write_only': True&#125; &#125; def validate(self, attrs): """ Check that the start is before the stop. """ if attrs['password'] != attrs['re_password']: raise serializers.ValidationError(_('密码不一致')) # 校验验证码 verify_result = Sms(attrs['mobile_phone']).verify_sms_code( attrs.pop('code')) if not verify_result: error = verify_result.get('error') raise ParseError(error) return attrs def create(self, validated_data): user = User( username=validated_data['mobile_phone'], mobile_phone=validated_data['mobile_phone'], ) user.set_password(validated_data['password']) user.save() return user 因为create()这个方法return了一个user实例，User里没有的字段code和re_password需要将write_only写在field参数里，不然会报以下错误123AttributeError: Got AttributeError when attempting to get a value for field `code` on serializer `UserRegisterSerializer`.The serializer field might be named incorrectly and not match any attribute or key on the `User` instance.Original exception text was: &apos;User&apos; object has no attribute &apos;code&apos;. 如果使用django-rest-swagger报以下错误1Can&apos;t read from server. It may not have the appropriate access-control-origin settings. 注释掉设置里的1# 'base_path': '127.0.0.1:8000/docs', serializer.data和serializer.validated_data在serializer只使用data参数实例化的时： serializer.data是原始数据（字符串），serializer.validated_data是进行数据验证并转换成对应数据类型的数据。 两者者必须在serializer调用is_valid方法后才能调用在serializer只使用instance参数实例化时： 只有serializer.data没有serializer.validated_data，并且serializer.data里的数据也是字符串； 没有方法is_valid； 即is_valid和validated_data只在有data参数实例化时才可调用； 在serializer里获取原始请求信息默认的，上下文信息会被传递到serializer里，所以在serializer可以直接使用self.context[&#39;request&#39;]来获取请求信息。（在要继承自viewsets.GenericViewSet的类里使用的serializer才能取到，如果是继承APIView的，自己传入即可serializer = self.serializer_class(data=request.data, context={&#39;request&#39;: request})） 自定义serializer字段自定义字段继承serializers.Field，to_representation方法处理出来的数据用来序列化显示，to_internal_value处理接收到的数据，get_attribute方法指定这个字段访问的实例属性，get_value方法指定12345678910111213141516class QiNiuField(serializers.Field): def get_attribute(self, instance): # （序列化时）从模型实例中取一个值给这个字段处理,也可以使用`source`参数指定 return instance.key def get_value(self, dictionary): # （反序列化时）从传入数据中提取一个值给这个字段处理 return super(QiNiuField, self).get_value(dictionary) def to_representation(self, value): # （序列化时）处理出来的数据用来序列化显示 return value.url def to_internal_value(self, data): # （反序列化时）处理接收到的数据 return data['key'] 嵌套序列化，传参问题官方文档中有这么一个例子Dealing with nested objects如果是以Content-Type:application/json形式传数据格式传数据，直接嵌套传就可以了{&#39;user&#39;: {&#39;email&#39;: &#39;foobar&#39;, &#39;username&#39;: &#39;doe&#39;}, &#39;content&#39;: &#39;baz&#39;}，但如果是以,但是如果以Content-Type:form-data或Content-Type:x-www-form-urlencoded上传，则上传user信息进不是嵌套，而是就.连接了，&quot;user.email&quot;:&quot;foobar&quot;.]]></content>
      <tags>
        <tag>Django</tag>
        <tag>restful</tag>
        <tag>api</tag>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django Rest framework使用问题及解决方法]]></title>
    <url>%2F2016%2F12%2F17%2Fdjango-rest-framework%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[更新记录2016-01-29 初稿 问题1ViewSet没有写serializer_class属性，而是重写了get_serializer_class()方法，出现1Cannot use OrderingFilter on a view which does not have either a &apos;serializer_class&apos; or &apos;ordering_fields&apos; attribute. 原因：因为启用了rest_framework.filters.OrderingFilter而没有设置ordering_fields解决方法：ViewSet里加ordering_fields属性，可是禁用rest_framework.filters.OrderingFilter 问题2ViewSet没有写queryset属性，而是重写了get_queryset()方法，出现1&apos;base_name&apos; argument not specified, and could not automatically determine the name from the viewset, as it does not have a &apos;.queryset&apos; attribute. 解决方法：需要在urls.py里给ViewSet注册Router时添加base_name（base_name为router为ViewSet注册url时自动添加的name前缀，如果未设置则从ViewSet的queryset里取，使用ViewSet自动生成的url name为&lt;base_name&gt;-list &lt;base_name&gt;-detail 等）urls.py1router.register(r&apos;users&apos;, UserViewSet, base_name=&apos;user&apos;) 问题3给url设置了namespaceurls.py1url(r'^api/', include(router.urls, namespace='api')), 访问部分接口出现1Could not resolve URL for hyperlinked relationship using view name &quot;user-detail&quot;. You may have failed to include the related model in your API, or incorrectly configured the `lookup_field` attribute on this field. 解决方法1：给所有的serializer里包含的外键字段手动设置view_name值（注意，继承HyperlinkedModelSerializer，会隐式添加一个HyperlinkedRelatedField字段url，而所有的外键都会变成HyperlinkedRelatedField字段，所以需要对两种类型字段手动设置view_name值）serializers.py12345678class ContactSerializer(serializers.HyperlinkedModelSerializer): class Meta: model = Contact fields = '__all__' extra_kwargs = &#123; 'url': &#123;'view_name': 'api:contact-detail'&#125;, 'user':&#123;'view_name':'api:user-detail'&#125; &#125; 解决方法2：启动drf基于NameSpace的版本控制settings.py12345REST_FRAMEWORK = &#123; …… 'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.NamespaceVersioning', ……&#125;]]></content>
      <tags>
        <tag>Django</tag>
        <tag>restful</tag>
        <tag>api</tag>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django Rest framework里的API请求频率控制]]></title>
    <url>%2F2016%2F12%2F17%2Fdjango-rest-framework%E9%87%8C%E7%9A%84api%E8%AF%B7%E6%B1%82%E9%A2%91%E7%8E%87%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[更新记录2016-08-25 初稿 Django Rest framework有自带的频率控制配置 全局设置123456789101112131415REST_FRAMEWORK = &#123; 'DEFAULT_THROTTLE_CLASSES': ( # 开启匿名用户接口请求频率限制 'rest_framework.throttling.AnonRateThrottle', # 开启授权用户接口请求频率限制 'rest_framework.throttling.UserRateThrottle' ), 'DEFAULT_THROTTLE_RATES': &#123; # 频率限制有second, minute, hour, day # 匿名用户请求频率 'anon': '100/day', # 授权用户请求频率 'user': '1000/day' &#125;&#125; 类视图单独配置123456789101112from rest_framework.response import Responsefrom rest_framework.throttling import UserRateThrottlefrom rest_framework.views import APIView class ExampleView(APIView): throttle_classes = (UserRateThrottle,) def get(self, request, format=None): content = &#123; 'status': 'request was permitted' &#125; return Response(content) 方法视图配置1234567@api_view(['GET'])@throttle_classes([UserRateThrottle])def example_view(request, format=None): content = &#123; 'status': 'request was permitted' &#125; return Response(content) 自定义方法一：123456class BurstRateThrottle(UserRateThrottle): scope = 'burst' class SustainedRateThrottle(UserRateThrottle): scope = 'sustained'...and the following settings. settings.py12345678910REST_FRAMEWORK = &#123; 'DEFAULT_THROTTLE_CLASSES': ( 'example.throttles.BurstRateThrottle', 'example.throttles.SustainedRateThrottle' ), 'DEFAULT_THROTTLE_RATES': &#123; 'burst': '60/min', 'sustained': '1000/day' &#125;&#125; 然后在视图里设置throttle_classes即可。 方法二：settings.py123456789REST_FRAMEWORK = &#123; 'DEFAULT_THROTTLE_CLASSES': ( 'rest_framework.throttling.ScopedRateThrottle', ), 'DEFAULT_THROTTLE_RATES': &#123; 'contacts': '1000/day', 'uploads': '20/day' &#125;&#125; 然后在类视图中设置throttle_scope1234567891011class ContactListView(APIView): throttle_scope = 'contacts' ... class ContactDetailView(APIView): throttle_scope = 'contacts' ... class UploadView(APIView): throttle_scope = 'uploads' ... 1. 匿名用户频率如果设置大于授权用户频率，则以授权用户频率为准。2. 频率限制是针对单个接口的频率，而不是所有接口的频率。]]></content>
      <tags>
        <tag>Django</tag>
        <tag>restful</tag>
        <tag>api， version</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在CentOS7上用MySQL+Nginx+Gunicorn+Supervisor部署Django]]></title>
    <url>%2F2016%2F12%2F08%2F%E5%9C%A8centos7%E4%BD%BF%E7%94%A8mysql-nginx-gunicorn%2Bsupervisor%E9%83%A8%E7%BD%B2django%2F</url>
    <content type="text"><![CDATA[本文记录下在CentOS下部署Django项目的步骤。 MySQL安装mysql和mysql-devel12yum install mysqlyum install mysql-devel 安装mysql-server123wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpmrpm -ivh mysql-community-release-el7-5.noarch.rpmyum install mysql-community-server 重启mysql服务1service mysqld restart 设置root密码初次安装mysql需要设置root密码12mysql -urootset password for &apos;root&apos;@&apos;localhost&apos; =password(&apos;password&apos;); 配置mysql在/etc/my.cnf文件中[mysql]和[mysql]中添加以下内容12345[mysql]default-character-set=utf8[mysqld]character-set-server=utf8 字符编码保持和/usr/share/mysql/charsets/Index.xml中的一致。 远程连接设置把在所有数据库的所有表的所有权限赋值给位于所有IP地址的root用户。1mysql&gt; grant all privileges on *.* to root@&apos;%&apos;identified by &apos;password&apos;; 如果是新用户而不是root，则要先新建用户1mysql&gt;create user &apos;username&apos;@&apos;%&apos; identified by &apos;password&apos;; 此时就可以进行远程连接了。 Virtualenv安装epel扩展源1yum install epel-release 安装pip1yum install python-pip 安装virtualenv和virtualenvwrapper1pip install virtualenv virtualenvwrapper 编辑~/.bashrc文件，结尾添加以下内容12export WORKON_HOME=~/.virtualenvssource /usr/bin/virtualenvwrapper.sh 然后执行以下命令使配置生效1source ~/.bashrc 创建env1mkvirtualenv explame 使用pip安装项目需要的包 WSGI在项目目录下新建nginx_wsgi.py文件1touch nginx_wsgi.py 添加如下内容12345678910111213141516171819import sysimport siteimport os # site-packagessite.addsitedir(&apos;/home/nginxuser/.virtualenvs/example/lib/python2.7/site-packages&apos;)# Add the project directory# sys.path.append(&apos;/home/nginxuser/nginxuser&apos;)PROJECT_DIR = &apos;/home/nginxuser/projects/example&apos;sys.path.insert(0, PROJECT_DIR)os.environ[&apos;DJANGO_SETTINGS_MODULE&apos;] = &apos;example.settings.prod&apos;# Activate your virtual envactivate_env = os.path.expanduser(&quot;/home/nginxuser/.virtualenvs/example/bin/activate_this.py&quot;)execfile(activate_env, dict(__file__=activate_env)) # after activite envfrom django.core.wsgi import get_wsgi_application application = get_wsgi_application() Nginx安装1yum install nginx 检查配置是否有错1nginx -t -c /etc/nginx/nginx.conf 启动nginx1service nginx start 设置开机自启1systemctl enable nginx 创建用户12useradd nginxuserpasswd nginxuser 修改nginx主配置1vim /etc/nginx/nginx.conf 非注释首行1user nginx 改为1user nginxuser 不然可能会出现网站静态文件访问报403问题。 新建网站运行配置1vim /etc/nginx/conf.d/example.conf 12345678910111213141516171819server &#123; listen 80; server_name example.com; charset utf-8; client_max_body_size 75M; access_log /home/nginxuser/projects/example/nginxlogs/access.log; error_log /home/nginxuser/projects/example/nginxlogs/error.log; location /static &#123; alias /home/nginxuser/projects/explame/static; &#125; location / &#123; proxy_pass http://127.0.0.1:8000; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; &#125; jk Gunicorn安装1pip install gunicorn 项目根目录下添加gunicorn运行配置文件gunicorn.conf.py123456import multiprocessingbind = &quot;127.0.0.1:8000&quot;workers = 2errorlog = &quot;/home/nginxuser/example/gunicorn.error.log&quot;#loglevel = &quot;debug&quot;proc_name = &quot;gunicorn_example&quot; 启动1sudo gunicorn example.nginx_wsgi:application -c /home/nginxuser/projects/example/gunicorn.conf.py 后台运行1sudo nohup gunicorn example.nginx_wsgi:application -c /home/nginxuser/projects/example/gunicorn.conf.py&amp; 如果运行报错先使用以下命令检查下nginx配置是否有错1nginx -t -c /etc/nginx/nginx.conf Supervisor安装1pip install supervisor 创建管理进程配置文件1vim /etc/supervisord.d/example.ini （需要注意：用 supervisord 管理时，gunicorn 的 daemon 选项需要设置为 False）12345678910111213141516[program:example]directory = /home/nginxuser/projects/example ; 程序的启动目录command = gunicorn example.nginx_wsgi:application -c /home/nginxuser/projects/example/gunicorn.conf.py ; 启动命令，可以看出与手动在命令行启动的命令是一样的autostart = true ; 在 supervisord 启动的时候也自动启动startsecs = 5 ; 启动 5 秒后没有异常退出，就当作已经正常启动了autorestart = true ; 程序异常退出后自动重启startretries = 3 ; 启动失败自动重试次数，默认是 3user = nginx ; 用哪个用户启动redirect_stderr = true ; 把 stderr 重定向到 stdout，默认 falsestdout_logfile_maxbytes = 20MB ; stdout 日志文件大小，默认 50MBstdout_logfile_backups = 20 ; stdout 日志文件备份数; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）stdout_logfile = /data/logs/usercenter_stdout.log; 可以通过 environment 来添加需要的环境变量，一种常见的用法是修改 PYTHONPATH; environment=PYTHONPATH=$PYTHONPATH:/path/to/somewhere 冒号后面要有空格 启动使用-c指定配置文件。1supervisord -c /etc/supervisord.conf 如果启动时遇到以下报错信息12Error: Another program is already listening on a port that one of our HTTP servers is configured to use. Shut this program down first before starting supervisord.For help, use /use/bin/supervisord -h 可以使用以下命令解决1sudo unlink /var/run/supervisor/supervisor.sock 命令行客户端工具supervisorctl启动时需要使用和supervisorctl使用一样的配置文件。1supervisorctl -c /etc/supervisord.conf 启动后进入supervisorctl的shell，在此shell里可以执行以下命令123456status # 查看程序状态start example # 启动example程序stop example # 关闭example程序restart example # 重启example程序reread # 读取有更新（增加）的配置文件，不会启动新添加的程序update # 重启配置文件修改过的程序 也可以不进shell执行以上命令123456supervisorctl status # 查看程序状态supervisorctl start example # 启动example程序supervisorctl stop example # 关闭example程序supervisorctl restart example # 重启example程序supervisorctl reread # 读取有更新（增加）的配置文件，不会启动新添加的程序supervisorctl update # 重启配置文件修改过的程序 开启web管理界面如果要开启web管理界面，打开/etc/supervisord.conf把下面几行取消注释即可1234:[inet_http_server] ; inet (TCP) server disabled by default:port=127.0.0.1:9001 ; (ip_address:port specifier, *:port for all iface):username=user ; (default is no username (open server)):password=123 ; (default is no password (open server))]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>centOS</tag>
        <tag>Nginx</tag>
        <tag>Gunicorn</tag>
        <tag>MySQL</tag>
        <tag>Supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm入门命令]]></title>
    <url>%2F2016%2F07%2F06%2Fnpm%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[更新记录2016-07-06 初稿 基础命令显示npm版号123npm -v# 或npm version 安装模块123456# 带-g为全局安装# 本地安装：package会被下载到当前所在目录，也只能在当前目录下使用。# 全局安装：package会被下载到到特定的系统目录下，安装的package能够在所有目录下使用。npm install &lt;package&gt; -g# 简写npm i &lt;package&gt; -g 升级全局安装的指定模块1npm update &lt;package&gt; -g 升级当前目录下的指定模块1npm update &lt;package&gt; 升级当前目录下全部模块1npm update 升级node自身123456# 安装一个叫n的模块npm install -g n# 升级到最新稳定版n stable# 升级到指定版本n v0.10.26 卸载移除指定模块12npm uninstall &lt;package&gt;# 别名：remove, rm, r, un, unlink 显示已安装模块1npm list 显示模块详细信息1npm show &lt;package&gt; 查看全局包安装路径1npm root -g 查看当前包安装路径1npm root 查看npm配置1npm config list 查看帮助1npm help 查看相关命令的帮助文档1npm help &lt;command&gt;]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome扩展/插件/应用推荐]]></title>
    <url>%2F2016%2F06%2F01%2Fchrome%E6%89%A9%E5%B1%95-%E6%8F%92%E4%BB%B6-%E5%BA%94%E7%94%A8%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[本文过期，请前行住自用软件推荐查看最新内容 插件/扩展 Adblock Plus广告拦截器，谁用谁知道。 Checker Plus for Gmail™Gmail/Inbox插件，不用打开网页处理邮件。 Wappalyzer探测当前网页正在使用的开源软件或者js类库，web开发者必备神器。 crxMouse Chrome Gestures鼠标手势。 Ghostery了解谁在跟踪您的网页浏览操作，并可禁用跟踪行为。 Google Keep Chrome 扩展程序将网页快速的保存到Google Keep中。 Google翻译支付在网页中划词翻译。 划词翻译划词翻译，支持谷歌、百度、有道、必应四大翻译和朗读引擎，访问Google比较因难的的可以用这个。 LastPass免费的密码管理管理器。 MindMap Tab在新标签页中快速编辑思维导图。 Octotree在浏览器左侧树形展示Github代码。 Prism Pretty美化代码（html、css、js、json……） Proxy SwitchyOmega你懂的。 Pushbullet快速的往其它设备发送消息。 Save to Pocket快速保存网页到Pocket。 Search by Image (by Google)浏览器右键增加Google的以图搜图功能。 v2ex plus优雅便捷的 V2EX 扩展。 Web Timer每个网站停留时间统计。 为知笔记网页剪辑器配合为知笔记，快速保存网页内容到为知笔记。 二维码（生成及识别）生成或识别二维码。 惠惠购物助手在主流电商网站页面上提供商品的历史价格，及在同款商品在其它平台的价格比较。 新浪微博图床微博是个好图床。 网页截图:注释&amp;批注捕获整个页面或任何部分，矩形，圆形，箭头，线条和文字，模糊敏感信息，一键上传分享。 应用 Postman功能强大的接口调试工具。 Google Keep - 记事和清单不解释。 Pocket不解释。 JSON Editor图形化json编辑工具。]]></content>
      <categories>
        <category>优化辅助</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>工具</tag>
        <tag>扩展</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django 1.9文档阅读笔记]]></title>
    <url>%2F2016%2F04%2F04%2Fdjango1-9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[更新记录2016-04-04 初稿2016-06-30 更新内容 模型Model _meta API 限制普通字段的选择范围choices，value-text，显示get_foo_display() 模型继承 抽象基类 默认继承元类 多表继承 一般情况不继承元类 代理模型 多重继承主要用于mix-in类 多表继承时使用parent_link=True显示指定OneToOne字段 模型字段参考与尚未定义的模型关联使用模型名字（字符串）而非本身（类） 关联自己使用self related_name relate_query_name 外键关联到特定字段to_field 限制外键的选择范围（可以是一个字典、一个Q 对象或者一个返回字典或Q对象的可调用对象）limit_choices_to 外键关联对象删除行为on_delete 1.8以后保存模型时，未保存的外键对象将被忽略，除非设置allow_unsaved_instance_assignment=True 关联自身的多对多关系默认对称，取消对称设置symmetrical=False ImageField中的height_field和width_field是用来存储存入图片的高度和宽度值的 ##执行查询 可自定义查询（高级查找）exclude多条件查询时是用or关系而不是and关系 F()用于模型内部字段间的比较支持加法、减法、乘法、除法、取模以及幂计算等算术操作支持.bitand() 和.bitor()位操作，update()也可以使用F()但有限制（在update 中你不可以使用F() 对象引入join —— 你只可以引用正在更新的模型的字段） 查询集缓存当只对查询集的部分进行求值时会检查缓存， 但是如果这个部分不在缓存中，那么接下来查询返回的记录都将不会被缓存。123&gt;&gt;&gt; queryset = Entry.objects.all()&gt;&gt;&gt; print([p.headline for p in queryset]) # Evaluate the query set.&gt;&gt;&gt; print([p.pub_date for p in queryset]) # Re-use the cache from the evaluation. 123&gt;&gt;&gt; queryset = Entry.objects.all()&gt;&gt;&gt; print queryset[5] # Queries the database&gt;&gt;&gt; print queryset[5] # Queries the database again 1234&gt;&gt;&gt; queryset = Entry.objects.all()&gt;&gt;&gt; [entry for entry in queryset] # Queries the database&gt;&gt;&gt; print queryset[5] # Uses cache&gt;&gt;&gt; print queryset[5] # Uses cache Q()可使用Q对象进行复杂查询 判断两相模型实例是否相同，直接使用==比较即可 默认批量删除对象时不会调用实例的delete方法 拷贝实例，把pk设置为None再save即可（如果是继承的，则pk和id都需要设置为None） update()方法也不会调用模型的save()方法，不会发出pre_save和post_save信号，字段的auto_now也不会起作用 一对多关联对象访问会缓存123&gt;&gt;&gt; e = Entry.objects.get(id=2)&gt;&gt;&gt; print(e.blog) # Hits the database to retrieve the associated Blog.&gt;&gt;&gt; print(e.blog) # Doesn't hit the database; uses cached version. 自定义反向管理器1.7+123456789from django.db import models class Entry(models.Model): #... objects = models.Manager() # Default Manager entries = EntryManager() # Custom Manager b = Blog.objects.get(id=1)b.entry_set(manager='entries').all() 查询集API 参考聚合一次创建多条数据（只有一条sql）bulk_create 根据提供的一组pk查询出所有对应的对象in_bulk 在查作者列表时要查每个作者有几篇博文123456789&gt;&gt;&gt; from django.db.models import Count&gt;&gt;&gt; authors = Author.object.all().annotate(Count('blog'))# authors[0]作者的博文数&gt;&gt;&gt; authors[0].blog__count3# 或&gt;&gt;&gt; authors = Author.object.all().annotate(number_of_blog=Count('blog'))&gt;&gt;&gt; authors[0].number_of_blog3 算出所有作者的年龄总合（不需要其它数据）12&gt;&gt;&gt; ageAuthor.objects.all().aggregate(Sum('age'))&#123;'age__sum': 26&#125; annotate和aggregate都可写入多个注解表达式annotate和aggregate可聚合关联对象 对注解进行过滤123# 查询出作者数大于1的书本# 只有一条sqlBook.objects.annotate(num_authors=Count('authors')).filter(num_authors__gt=1) 但顺序不一样，结果也不同，如：12Publisher.objects.annotate(num_books=Count('book')).filter(book__rating__gt=3.0)Publisher.objects.filter(book__rating__gt=3.0).annotate(num_books=Count('book')) 对注解项进行排序1Book.objects.annotate(num_authors=Count('authors')).order_by('num_authors') values()使用注解时要小心，如果values()在注解之前，会对结果进行分组，注解会作用在分组上而不是整个查询集上 与默认排序交换或order_by()¶ 在查询集中的order_by() 部分(或是在模型中默认定义的排序项) 会在选择输出数据时被用到，即使这些字段没有在 values() 调用中被指定。这些额外的字段可以将相似的数据行分在一起，也可以让相同的数据行相分离。在做计数时， 就会表现地格外明显： 通过例子中的方法，假设有一个这样的模型： 123456from django.db import models class Item(models.Model): name = models.CharField(max_length=10) data = models.IntegerField() class Meta: ordering = ["name"] 关键的部分就是在模型默认排序项中设置的name字段。如果你想知道每个非重复的data值出现的次数，可以这样写： 12# Warning: not quite correct!Item.objects.values("data").annotate(Count("id")) …这部分代码想通过使用它们公共的 data 值来分组 Item对象，然后在每个分组中得到 id 值的总数。但是上面那样做是行不通的。这是因为默认排序项中的 name也是一个分组项，所以这个查询会根据非重复的 (data, name) 进行分组，而这并不是你本来想要的结果。所以，你应该这样改写： 1Item.objects.values("data").annotate(Count("id")).order_by() …这样就清空了查询中的所有排序项。 你也可以在其中使用 data ，这样并不会有副作用，这是因为查询分组中只有这么一个角色了。 这个行为与查询集文档中提到的 distinct() 一样，而且生成规则也一样：一般情况下，你不想在结果中由额外的字段扮演这个角色，那就清空排序项，或是至少保证它仅能访问 values()中的字段。 静态文件http://python.usyiyi.cn/django/intro/tutorial06.htmlhttp://python.usyiyi.cn/django/ref/templates/builtins.html 12345678&#123;% load static %&#125;&lt;link rel="stylesheet" type="text/css" href="&#123;% static user_stylesheet %&#125;" /&gt;&lt;link rel="stylesheet" type="text/css" href="&#123;% static 'polls/style.css' %&#125;" /&gt;&lt;link rel="stylesheet" type="text/css" href="&#123;% get_static_prefix %&#125;pools/style.css" /&gt;&#123;% get_static_prefix as STATIC_PREFIX %&#125;&lt;link rel="stylesheet" type="text/css" href="&#123;&#123; STATIC_PREFIX &#125;&#125;pools/style.css" /&gt;&#123;% static "images/hi.jpg" as myphoto %&#125;&lt;img src="&#123;&#123; myphoto &#125;&#125;"&gt;&lt;/img&gt; 还有get_media_prefix 模型实例参考从数据库中重新加载值Model.refresh_from_db(using=None, fields=None, **kwargs) 返回模型中当前所有延迟字段的属性名称Model.get_deferred_fields() 验证对象 字段的基本验证会最先跑，但不管前面运行是否通过，对于每个字段，如果Field.clean() 方法抛出 ValidationError，那么将不会调用该字段对应的clean_()方法。 但是，剩余的字段的验证方法仍然会执行。先跑form里验证，再跑modle验证先跑验证器，再跑clean先跑单个字段验证，再跑整体验证Model.clean_field()会覆盖Model里所有字段的验证器，但不会对Form里的验证器产生影响 验证模型的字段Model.clean_fields(exclude=None)验证模型的完整性Model.clean()验证模型的唯一性Model.validate_unique(exclude=None)调用full_clean()时，上面三个方法都会执行（执行顺序即上面的书写顺序），ModelForm的is_valid()也会执行上所有验证Model.full_clean(exclude=None, validate_unique=True) save()时，full_clean()不会被调用，如果想验证数据，可手动调用 Model.clean()时，引发特定字段的异常使用一个字典实例化ValidationError即可或使用add_error(field, msg)方法 在数据库字段值的基础上进行简单的算法操作，应该尽量使用F()表达式，避免问题竞态条件 指定要保存的字段 如果传递给save() 的update_fields 关键字参数一个字段名称列表，那么将只有该列表中的字段会被更新。如果你想更新对象的一个或几个字段，这可能是你想要的。不让模型的所有字段都更新将会带来一些轻微的性能提升。例如： 12product.name = 'Name changed again'product.save(update_fields=['name']) update_fields 参数可以是任何包含字符串的可迭代对象。空的update_fields可迭代对象将会忽略保存。如果为None值，将执行所有字段上的更新。 指定update_fields将强制使用更新操作。 当保存通过延迟模型加载（only() 或defer()）进行访问的模型时，只有从数据库中加载的字段才会得到更新。这种情况下，有个自动的update_fields。如果你赋值或者改变延迟字段的值，该字段将会添加到更新的字段中。 new in 1.9使用Model.delete()删除多表继承的子表数据时，使用keep_parents=True可以保留上级数据，默认为False`返回值为删除数据的条数 DateField和DateTimeField字段如果null=False则支持下面两个方法12Model.get_next_by_FOO(**kwargs)¶ Model.get_previous_by_FOO(**kwargs) 管理器django遇到的第一个管理器为默认管理器 如果需要访问关联对象调用关联对象的默认管理器，需要在管理器中加use_for_related_fields=True，不然会调用朴素管理器1234567891011121314151617181920212223242526272829303132# -*- coding: utf-8 -*- from django.db import models class DefaultManager(models.Manager): def get_queryset(self): queryset = super(DefaultManager, self).get_quertset().filter(is_delete=False) return queryset class Author(models.Model): name = models.CharField(max_length=100) is_delete = models.BooleanField() objects = DefaultManager() class Post(models.Model): author = models.ForeignKey(Author) title = models.CharField(max_length=100) content = models.TextField() is_delete = models.BooleanField() objects = DefaultManager() author = Author.objects.get(pk=1)post = Post.objects.get(pk=2) # 调用DefaultManager管理器author.post_set.all()# 调用朴素管理器，如果要调用DefaultManager管理器，需要设置DefaultManager管理器的类变量use_for_related_fields=Truepost.author 注：朴素管理器里找不到的方法会在默认管理器里查找 从Manager中调用自定义的QuerySet 进行原始的SQL查询1Manager.raw(raw_query, params=None, translations=None) django.db.connection对象提供了常规数据库连接的方式。为了使用数据库连接，先要调用connection.cursor()方法来获取一个游标对象之后，调用cursor.execute(sql, [params])来执行sql语句，调用cursor.fetchone()或者cursor.fetchall()来返回结果行。 数据库事务详细笔记见django1.8事务.md 将每个HTTP请求封装在一个数据库事务中settings中设置ATOMIC_REQUESTS=True 单独给一个方法加上数据库事务控制使用atomic123456from django.db import transaction @transaction.atomicdef viewfunc(request): # This code executes inside a transaction. do_stuff() 或123456789from django.db import transaction def viewfunc(request): # This code executes in autocommit mode (Django's default). do_stuff() with transaction.atomic(): # This code executes inside a transaction. do_more_stuff() 避免在 atomic里捕获异常! 查询表达式使用数据库的方法12from django.db.models import Func, F queryset.annotate(field_lower=Func(F('field'), function='LOWER')) 或123class Lower(Func): function = 'LOWER' queryset.annotate(field_lower=Lower(F('field'))) 条件表达式高级用法查看在线版WhenCase 数据库函数Coalesce 接收一个含有至少两个字段名称或表达式的列表，返回第一个非空的值（空字符串不认为是一个空值） 将遗留数据库整合到Django根据遗留数据库生成models1python manage.py inspectdb &gt; models.py 为模型提供初始数据使用fixtures123456789101112131415161718[ &#123; &quot;model&quot;: &quot;myapp.person&quot;, &quot;pk&quot;: 1, &quot;fields&quot;: &#123; &quot;first_name&quot;: &quot;John&quot;, &quot;last_name&quot;: &quot;Lennon&quot; &#125; &#125;, &#123; &quot;model&quot;: &quot;myapp.person&quot;, &quot;pk&quot;: 2, &quot;fields&quot;: &#123; &quot;first_name&quot;: &quot;Paul&quot;, &quot;last_name&quot;: &quot;McCartney&quot; &#125; &#125;] 导入数据命令1python manage.py loaddata &lt;fixturename&gt; 数据库访问优化添加索引，比任何查询语法优化都来的重要理解查询集QuerySets是延迟的。什么时候它们被计算出来。数据在内存中如何存储。 使用cached_property装饰器，只要是同一个实例，一个方法就只会执行一次使用with模版标签使用iterator迭代器 在数据库中而不是python中做数据库工作使用过滤器和反射过滤器对数据进行过滤使用F()表达式使用注解和聚合使用原始SQL 用唯一的或被索引的列来检索独立对象 在不同位置多次访问数据库，每次获取一个数据集，不如在一次查询中获取它们。比如循环的时候。 使用select_related()和prefetch_related() 不检索你不需要的信息使用QuerySet.values()和QuerySet.values_list() 使用QuerySet.defer()和QuerySet.only() 计算数量不要使用len(queryset)而是使用QuerySet.count() 判断是否存在结果使用QuerySet.exists()而不是用if queryset 但不要过度使用count()和exists()，如果你本来就需要里面的数据，那就不要使用 使用QuerySet.update()和QuerySet.delete()批量操作数据 直接使用外键的值123entry.blog_id# 而不是entry.blog.id 如果你并在意结果集的顺序，不要进行排序，移除Meta.ordering 创建对象时尽可能使用bulk_create()来减少sql查询数量这也适用于ManyToManyFields的情况，一起add而不是一个一个add1234my_band.members.add(me, my_friend) #更优于 my_band.members.add(me)my_band.members.add(my_friend) URL调度器url捕获的参数永远是字符串 在根url上获取的参数不影响参数传递123456789101112131415# In settings/urls/main.pyfrom django.conf.urls import include, url urlpatterns = [ url(r'^(?P&lt;username&gt;\w+)/blog/', include('foo.urls.blog')),] # In foo/urls/blog.pyfrom django.conf.urls import urlfrom . import views urlpatterns = [ url(r'^$', views.blog.index), url(r'^archive/$', views.blog.archive),] 在上面的例子中，捕获的”username”变量将被如期传递给include()指向的URLconf。 可嵌套123456from django.conf.urls import url urlpatterns = [ url(r'blog/(page-(\d+)/)?$', blog_articles), # bad url(r'comments/(?:page-(?P&lt;page_number&gt;\d+)/)?$', comments), # good] 传递额外的参数123456from django.conf.urls import urlfrom . import views urlpatterns = [ url(r'^blog/(?P&lt;year&gt;[0-9]&#123;4&#125;)/$', views.year_archive, &#123;'foo': 'bar'&#125;),] 当url捕获的参数和字典中传递的参数同名时，将忽略url捕获的参数而使用字典里的参数值 传递额外的参数给include()123456789101112131415# main.pyfrom django.conf.urls import include, url urlpatterns = [ url(r'^blog/', include('inner'), &#123;'blogid': 3&#125;),] # inner.pyfrom django.conf.urls import urlfrom mysite import views urlpatterns = [ url(r'^archive/$', views.archive), url(r'^about/$', views.about),] 效果等同123456789101112131415# main.pyfrom django.conf.urls import include, urlfrom mysite import views urlpatterns = [ url(r'^blog/', include('inner')),] # inner.pyfrom django.conf.urls import url urlpatterns = [ url(r'^archive/$', views.archive, &#123;'blogid': 3&#125;), url(r'^about/$', views.about, &#123;'blogid': 3&#125;),] 反查带命名空间的URL 编写视图HttpResponse子类，状态码 HttpResponseRedirect 临时重定向，302 HttpResponsePermanentRedirect 永久重定向，301 HttpResponseNotModified 没有任何修改，304 HttpResponseBadRequest 语义有误码，当前请求不被服务器理解，400 HttpResponseNotFound 页面没找到，404 HttpResponseForbidden 服务器理解请求，但拒绝执行，403 HttpResponseNotAllowed 请求中指定的请求方式不能用于请求相应资源，405 HttpResponseGone 请求的资源在服务器上已经不可用，而且没有已知的转发地址，410 HttpResponseServerError 服务器遇到了一个意外的错误，导致无法完成对请求的处理，500 HttpResponse(status=201) 自定义返回状态码 重写错误视图（在url中）1234handler404 = &apos;mysite.views.my_custom_page_not_found_view&apos;handler500 = &apos;mysite.views.my_custom_error_view&apos; handler403 = &apos;mysite.views.my_custom_permission_denied_view&apos;handler400 = &apos;mysite.views.my_custom_bad_request_view&apos; Django 的快捷函数template_name可传一个模版序列，django将使用存在的第一个模版 redirect(to, [permanent=False, ]*args, **kwargs)[source] 为传递进来的参数返回HttpResponseRedirect 给正确的URL 。参数可以是： 一个模型：将调用模型的get_absolute_url() 函数 一个视图，可以带有参数：将使用urlresolvers.reverse 来反向解析名称 一个绝对的或相对的URL，将原样作为重定向的位置。 默认返回一个临时的重定向；传递permanent=True 可以返回一个永久的重定向。 get_object_or_404(klass, *args, **kwargs)可以传Model也可以传QuerySet实例和关联的管理器get_list_or_404(klass, *args, **kwargs)可以传Model也可以传QuerySet实例和关联的管理器 视图装饰器按需内容处理django.views.decorators.http包里的装饰器可以基于请求的方法来限制对视图的访问。若条件不满足会返回 django.http.HttpResponseNotAllowed。require_http_methods(request_method_list)限制视图只能服务于规定的http方法（需要大写）require_GET()require_POST()require_safe()只允许视图接受GET和HEAD方法的装饰器。 1@condition(etag_func=None, last_modified_func=None) 1@last_modified(last_modified_func) 根据最后修改时间来决定是否运行视图，可减少流量1@etag(etag_func) etag（版本？）和last_modified不能同时使用 GZip对内容进行压缩，节省流量，但增加处理时间 vary_on_cookievary_on_headers基于特定的请求头部来控制缓存 never_cache Request 对象和Response 对象HttpRequest对象(除非特殊说明，所有属性都是只读，session属性是个例外)HttpRequest.scheme 请求方案（通常为http或https）HttpRequest.body 字节字符串，表示原始http请求正文HttpRequest.path 字符串，表示请求的页面的完整路径，不包含域名HttpRequest.path_info 在某些Web 服务器配置下，主机名后的URL 部分被分成脚本前缀部分和路径信息部分。path_info 属性将始终包含路径信息部分，不论使用的Web 服务器是什么。使用它代替path 可以让代码在测试和开发环境中更容易地切换。 例如，如果应用的WSGIScriptAlias 设置为”/minfo”，那么当path 是”/minfo/music/bands/the_beatles/“ 时path_info 将是”/music/bands/the_beatles/“。HttpRequest.method 请求使用的http方法，大写HttpRequest.encoding 表示提交的数据的编码方式，可写HttpRequest.GETHttpRequest.POSTHttpRequest.REQUEST不建议使用，使用GET和POST代替HttpRequest.COOKIES 字典，键和值都是字符串HttpRequest.FILES 类似字典的对象，包含所有的上传文件，带有enctype=&quot;multipart/form-data&quot;才会有数据HttpRequest.META 标准的python字典，包含所有http请求头部HttpRequest.userHttpRequest.session 类似字典的对象HttpRequest.urlconf 如果其它地方设置了，则用来取代ROOT_URLCONFHttpRequest.resolver_match 会在url解析之后设置，一个ResolverMatch实例，表示解析之后的urlHttpRequest.get_host() 获取原始主机地址HttpRequest.get_port() 获取请求端端口号HttpRequest.get_full_path() 返回完整的path，包括查询字符串HttpRequest.build_absolute_uri(location) 返回绝对urlHttpRequest.get_signed_cookie(key, default=RAISE_ERROR, salt=&#39;&#39;, max_age=None) 返回签名过的Cookie对应的值HttpRequest.is_secure() 如果请求是通过https发起的，则返回TrueHttpRequest.is_ajax() 如果请求是通过XMLHttpRequest发起的，则返回True12345HttpRequest.read(size=None)HttpRequest.readline()HttpRequest.readlines()HttpRequest.xreadlines()HttpRequest.__iter__() 这几个方法实现类文件的接口用于读取HttpRequest· 实例 QueryDict对象request.POST 和request.GET 的QueryDict 在一个正常的请求/响应循环中是不可变的。若要获得可变的版本，需要使用.copy()。 TemplateResponse 和SimpleTemplateResponseSimpleTemplateResponseTemplateResponseTemplateResponse 对象和普通的django.http.HttpResponse 一样可以用于任何地方。它可以用来作为render() 和render_to_response() 的另外一种选择。 例如，下面这个简单的视图使用一个简单模板和包含查询集的上下文返回一个TemplateResponse：1234from django.template.response import TemplateResponse def blog_index(request): return TemplateResponse(request, 'entry_list.html', &#123;'entries': Entry.objects.all()&#125;) 文件上传1234def handle_uploaded_file(f): with open('some/file/name.txt', 'wb+') as destination: for chunk in f.chunks(): destination.write(chunk) 遍历UploadedFile.chunks()，而不是使用read()，能确保大文件并不会占用系统过多的内存。 上传处理器12(&quot;django.core.files.uploadhandler.MemoryFileUploadHandler&quot;,&quot;django.core.files.uploadhandler.TemporaryFileUploadHandler&quot;,) MemoryFileUploadHandler 和TemporaryFileUploadHandler一起提供了Django的默认文件上传行为，将小文件读取到内存中，大文件放置在磁盘中。 你可以编写自定义的处理器，来定制Django如何处理文件。例如，你可以使用自定义处理器来限制用户级别的配额，在运行中压缩数据，渲染进度条，甚至是向另一个储存位置直接发送数据，而不把它存到本地。关于如何自定义或者完全替换处理器的行为，详见编写自定义的上传处理器。 更改上传处理器的行为12345678DEFAULT_FILE_STORAGEFILE_CHARSETFILE_UPLOAD_HANDLERSFILE_UPLOAD_MAX_MEMORY_SIZEFILE_UPLOAD_PERMISSIONSFILE_UPLOAD_TEMP_DIRMEDIA_ROOTMEDIA_URL 在运行中更改上传处理器1request.upload_handlers.insert(0, ProgressBarUploadHandler()) 注意 你只可以在访问request.POST或者request.FILES之前修改上传处理器– 在上传处理工作执行之后再修改上传处理就毫无意义了。如果你在读取request.FILES之后尝试修改request.upload_handlers，Django会抛出异常。 所以，你应该在你的视图中尽早修改上传处理器。 CsrfViewMiddleware 也会访问request.POST，它是默认开启的。意思是你需要在你的视图中使用csrf_exempt()，来允许你修改上传处理器。接下来在真正处理请求的函数中，需要使用csrf_protect()。注意这意味着处理器可能会在CSRF验证完成之前开始接收上传文件。例如： django.views.decorators.csrf import csrf_exempt, csrf_protect 1234567@csrf_exemptdef upload_file_view(request): request.upload_handlers.insert(0, ProgressBarUploadHandler()) return _upload_file_view(request) @csrf_protectdef _upload_file_view(request): ... # Process request File对象File类ContentFile类ImageFile类 比File多了width和height属性附加到对象的文件有额外的方法1File.save(name, content[, save=True]) 提供文件名和内容保存一个新文件，不会替换已存在文件，但会创建一个新文件，并且更新对象来指向它。测试出来直接car.save()也不会覆盖已存在文件，如果有重写会在原有名字后面加字符串如果save为True，模型的save()方法会在文件保存之后调用。这就是说，下面两行：123456&gt;&gt;&gt; car.photo.save('myphoto.jpg', content, save=False)&gt;&gt;&gt; car.save()``` 等价于：```python&gt;&gt;&gt; car.photo.save('myphoto.jpg', content, save=True) 从模型实例中移除文件，并且删除内部文件1File.delete([save=True]) 在页面展示中，ImageFile自带的清除勾选框勾选后只是清除了数据库中这具字段的值，并不会删除文件系统里对应的文件，而File.delete()会删除文件系统里的文件 文件储存APIDefaultStorageFileSystemStorageStorage 管理文件123456from django.db import models class Car(models.Model): name = models.CharField(max_length=255) price = models.DecimalField(max_digits=5, decimal_places=2) photo = models.ImageField(upload_to='cars') photo有以下方法photo.path相对路径photo.url绝对路径 实际测试有出入1234567891011# 官方示例&gt;&gt;&gt; car.photo.path'/media/cars/chevy.jpg'&gt;&gt;&gt; car.photo.url'http://media.example.com/cars/chevy.jpg'# 实际测试结果&gt;&gt;&gt; car.photo.path'E:\workspace\parking\parking\upload\20151230171832_0.jpg'&gt;&gt;&gt; car.photo.url'/upload/20151230171832_0.jpg' 更改一个文件的存储位置123456789101112&gt;&gt;&gt; import os&gt;&gt;&gt; from django.conf import settings&gt;&gt;&gt; initial_path = car.photo.path&gt;&gt;&gt; car.photo.name = 'cars/chevy_ii.jpg'&gt;&gt;&gt; new_path = settings.MEDIA_ROOT + car.photo.name&gt;&gt;&gt; # Move the file on the filesystem&gt;&gt;&gt; os.rename(initial_path, new_path)&gt;&gt;&gt; car.save()&gt;&gt;&gt; car.photo.path'/media/cars/chevy_ii.jpg'&gt;&gt;&gt; car.photo.path == new_pathTrue 编写自定义存储系统 必须是django.core.files.storage.Storage的子类 Django必须能够不带任何参数来实例化 必须实现 _open() 和 _save()方法，以及任何适合于你的储存类的其它方法 你的储存类必须是 可以析构的，所以它在迁移中的一个字段上使用的时候可以被序列化。只要你的字段拥有自己可以序列化的参数，你就可以为它使用django.utils.deconstruct.deconstructible类装饰器（这也是Django用在FileSystemStorage上的东西） 基于类的视图基于类的内建通用视图ListView类视图中，默认的对象列表名除了object_list，还有一个&lt;model_name&gt;_list 使用基于类的视图处理表单如果对应模型存在get_absolute_url方法的前提下CreateView和UpdateView类视图的success_url默认使用get_absolute_url 如何定义form_class，即使form_class是ModelForm也还是需要指定模型 如果没有定义form_class，则必须定义fields，fields和form_class不能同时存在 如果模型某个字段存的是模板路径，并且想通过此字段来动态的控制表单页的模板，可通过template_name_field来指定此字段。 Mixin基于类的视图的MixinContextMixin所有基于类的通用视图的这个模板Context 都包含一个view 变量指向视图实例。 Use alters_data where appropriate注意，将视图实例包含在模板Context 中可能将有潜在危险的方法暴露给模板作者。为了避免在模板中被调用类似这样的方法，可以在这些方法上设置alters_data=True。更多信息，参见渲染模板Context 的文档。很显然，调用某些变量会带来副作用，允许模板系统访问它们将是愚蠢的还会带来安全漏洞。 每个Django 模型对象的delete() 方法就是一个很好的例子。模板系统不应该允许下面的行为： I will now delete this valuable data. 设置可调用变量的alters_data 属性可以避免这点。如果变量设置alters_data=True ，模板系统将不会调用它，而会无条件使用string_if_invalid 替换这个变量。Django 模型对象自动生成的delete() 和save() 方法自动 设置alters_data=True。 例如：123def sensitive_function(self): self.database_record.delete() sensitive_function.alters_data = True 有时候，处于某些原因你可能想关闭这个功能，并告诉模板系统无论什么情况下都不要调用变量。设置可调用对象的do_not_call_in_templates 属性的值为True 可以实现这点。模板系统的行为将类似这个变量是不可调用的（例如，你可以访问可调用对象的属性）。query_pk_and_slug如果为True,get_object()将使用两者一起来查找。可以防止只使用pk时，如果pk连续，直接被攻击者都遍历pk获取整个列表 内建基于类的视图的API123urlpatterns = [ url(r'^view/$', MyView.as_view(size=42)),] 视图参数的线程安全性传递给视图的参数在视图的每个实例之间共享。这表示不应该使用列表、字典或其它可变对象作为视图的参数。如果你真这么做而且对共享的对象做过修改，某个用户的行为可能对后面访问同一个视图的用户产生影响。 基于类的通用视图 —— 索引使用Django输出CSV12345678910111213import csvfrom django.http import HttpResponse def some_view(request): # Create the HttpResponse object with the appropriate CSV header. response = HttpResponse(content_type='text/csv') response['Content-Disposition'] = 'attachment; filename="somefilename.csv"' writer = csv.writer(response) writer.writerow(['First row', 'Foo', 'Bar', 'Baz']) writer.writerow(['Second row', 'A', 'B', 'C', '"Testing"', "Here's a quote"]) return response 使用Django输出PDF12345678910111213141516171819from reportlab.pdfgen import canvasfrom django.http import HttpResponse def some_view(request): # Create the HttpResponse object with the appropriate PDF headers. response = HttpResponse(content_type='application/pdf') response['Content-Disposition'] = 'attachment; filename="somefilename.pdf"' # Create the PDF object, using the response object as its "file." p = canvas.Canvas(response) # Draw things on the PDF. Here's where the PDF generation happens. # See the ReportLab documentation for the full list of functionality. p.drawString(100, 100, "Hello world.") # Close the PDF object cleanly, and we're done. p.showPage() p.save() return response 中间件中间件的顺序很重要接受请求时，自上向下调用中间件返回响应时，自下向上调用中间件process_request(request)在django决定执行哪个视图之前（也就是解析url之前）被调用返回None继续处理请求返回HttpResponse不再去调用其它的request、view 或exception 中间件，或对应的视图，直接调用响应阶段的中间件，并返回结果 process_view(request, view_func, view_args, view_kwargs)注：view_args和view_kwargs都不包含request在django调用视图之前被调用返回None继续处理请求返回HttpResponse不再去调用其它的view 或exception 中间件，或对应的视图，直接调用响应阶段的中间件，并返回结果 注意在中间件内部，从process_request 或process_view 中访问request.POST 或request.REQUEST 将阻碍该中间件之后的所有视图无法修改请求的上传处理程序，一般情况下要避免这样使用。类CsrfViewMiddleware可以被认为是个例外，因为它提供csrf_exempt() 和csrf_protect()两个装饰器，允许视图显式控制在哪个点需要开启CSRF验证。 process_template_response(request, response)在视图刚好执行完毕之后被调用必须返回一个实现了render方法的响应对象 process_response(request, response)在所有响应返回浏览器之前被调用必须返回HttpResponse或者StreamingHttpResponse对象处理流式响应 process_exception(request, exception)在视图抛出异常时被调用返回None返回HttpResponse process_template_response和响应中间件会被调用在处理响应期间，中间件的执行顺序是倒序执行的，这包括process_exception，如果一个中间件的process_exception返回了一个响应，那么这个中间件上面的中间件中的process_exception都不会被调用 __init__()大多数中间件类都不需要初始化方法django初始化中间件无需任何参数，所以不能定义一个有参数的__init__方法init不会每次请求都执行，只在Web服务器响应第一个请求时执行 标记中间件不被使用init抛出django.core.exceptions.MiddlewareNotUsed`异常，django会从中间件处理过程中移动这部分中间件，并且当DEBUG为True的时候在django.request记录器中记录调试信息。 中间件类不能是任何类的子类 中间件可以放在python路径中的任务位置正常123456789101112131415161718192021A.initB.initC.initD.initA.process_requestB.process_requestC.process_requestD.process_requestA.process_viewB.process_viewC.process_viewD.process_view D.process_template_responseC.process_template_responseB.process_template_responseA.process_template_responseD.process_responstC.process_responstB.process_responstA.process_responst 视图异常1234567891011121314151617A.initB.initC.initD.initA.process_requestB.process_requestC.process_requestD.process_requestA.process_viewB.process_viewC.process_viewD.process_viewD.process_responstC.process_responstB.process_responstA.process_responst django中可用的中间件class CommonMiddlewareDISALLOWED_USER_AGENTS禁用匹配的user-agents访问网站APPEND_SLASH如果url结尾没有斜杠结尾，并且没有找到匹配的url，django会在结尾加上斜杠再匹配一次PREPEND_WWW如果url会重定向到www到头的网址USE_ETAGS设置来处理ETag。如果设置USE_ETAGS为True，Django会通过MD5-hashing处理页面的内容来为每一个页面请求计算Etag，并且如果合适的话，它将会发送携带Not Modified的响应。 class BrokenLinkEmailsMiddleware向MANAGERS 发送死链提醒邮件 class GZipMiddleware为支持GZip压缩的浏览器压缩内容建议放在中间件配置列表的第一个可通过gzip_page()装饰器使用独立的GZip压缩 class ConditionalGetMiddlewareclass LocaleMiddeware基于请求中的数据开启语言选择，它可以为每个用户进行定制。 class MessageMiddleware开启基于Cookie和会话的消息支持 class SecurityMiddleware中间件的排序 模版DjangoTemplates引擎OPTIONS配置项中接受以下参数string_if_invalid当模版变量无效时，使用此值代替可使用comment和endcomment进行多行注释 Django模版语言当模版系统遇到.时，按下面顺序查询从技术上来说，当模版系统遇到点(“.”)，它将以这样的顺序查询： 字典查询（Dictionary lookup） 属性或方法查询（Attribute or method lookup） 数字索引查询（Numeric index lookup） 模版变量最终解释成字面量，而不是变量值 load可接受多个库名称load humanize i18nload不支持继承 内置标签与过滤器标签filter对一段内容进行过滤，使用|对多个过滤器进行连接，且过滤器可以有参数比如一段纯文本不能使用之前说的过滤器写法，则可以使用filterfirstof输出第一个不为False的参数1&#123;% firstof var1 var2|safe var3 &quot;&lt;strong&gt;fallback value&lt;/strong&gt;&quot;|safe %&#125; ifchanged检查循环中的一个值从最近一次重复其是否改变，支持`else with可往include的模版里传上下文件变量1&#123;% include &quot;name_snippet.html&quot; with person=&quot;Jane&quot; greeting=&quot;Hello&quot; %&#125; 1&#123;% include &quot;name_snippet.html&quot; with greeting=&quot;Hi&quot; only %&#125; 1&#123;% lorem %&#125; 设计人员工具，好像是生成随机单词和段落123&#123;% lorem %&#125;&#123;% lorem 3 p %&#125;&#123;% lorem 10 w random %&#125; 人性化apnumber转换整数或整数的字符串形式为英文描述1 会变成oneintcomma转换成第三位带一个逗号4500 会变成 4,500intword将大的整数转换为友好的文字表示1000000 会变成 1.0 millionnaturalday对于当天或者一天之内的日期， 返回“今天”，“明天”或者“昨天”，视情况而定。否则，使用传进来的格式字符串给日期格式化naturaltime对于日期时间的值，返回一个字符串来表示多少秒、分钟或者小时之前例如（其中“现在”是2007年2月17日16时30分0秒）：17 Feb 2007 16:30:00 会变成 now17 Feb 2007 16:29:31 会变成 29 seconds agoordinal将一个整数或是整数的字符串，转换为它的序数词1 会变成 1st2 会变成 2nd3 会变成 3rd Django 模板语言：面向Python程序员string_if_invalid建议只在调试时设置，调试完成后就关闭，开发时最好不要使用，不然可能会遇到渲染问题 每个上下文都包含True False None [使用Context对象]这里比较难理解1234Context.get(key, otherwise=None)Context.pop()Context.push()Context.update(other_dict) 上下文处理器应用的时机上下文处理器应用在上下文数据的顶端。也就是说，上下文处理器可能覆盖你提供给Context 或RequestContext 的变量，所以要注意避免与上下文处理器提供的变量名重复。如果想要上下文数据的优先级高于上下文处理器，使用下面的模式：123from django.template import RequestContextrequest_context = RequestContext(request)request_context.push(&#123;"my_name": "Adrian"&#125;) Django 通过这种方式允许上下文数据在render() 和 TemplateResponse 等API 中覆盖上下文处理器。你还可以赋予RequestContext一个额外的处理器列表，使用第三个可选的位置参数processors。在下面的示例中，RequestContext 实例获得一个ip_address 变量123456def some_view(request): # ... c = RequestContext(request, &#123; 'foo': 'bar', &#125;, ['ip_address':'127.0.0.1']) return HttpResponse(t.render(c)) 上面例子中ip_address也会加入到上下文中 内建的模板上下文处理器下面是内奸的上下文处理器所添加的内容django.contrib.auth.context_processors.auth user perms django.template.context_processors.debug debug sql_queryes一个{‘sql’: …, ‘time’: …} 字典的列表，表示请求期间到目前为止发生的每个SQL 查询及花费的时间。这个列表按查询的顺序排序，并直到访问时才生成。 django.template.context_processors.i18n MEDIA_URL django.template.context_processors.static STATIC_URL django.template.context_processors.csrf csrf_token django.template.context_processors.request request django.contrib.messages.context_processors.messages messages DEFAULT_MESSAGE_LEVELS 自定义模板标签和过滤器自定义过滤器12345678910111213from django import templateregister = template.Library()@register.filter(name='cut') register.filter('cut', cut)register.filter('lower', lower)# ordef cut(value, arg): return value.replace(arg, '') @register.filterdef lower(value): return value.lower() 可使用SafeData来验证是否是安全数据123if isinstance(value, SafeData): # Do something with the "safe" string. ... 或使用is_safe来控制只接收的安全的数据123@register.filter(is_safe=True)def myfilter(value): return value 自定义标签12345678import datetimefrom django import template register = template.Library() @register.simple_tagdef current_time(format_string): return datetime.datetime.now().strftime(format_string) 1&#123;% show_results poll %&#125; 写一个标签，实现下面的效果12345&lt;ul&gt; &lt;li&gt;First choice&lt;/li&gt; &lt;li&gt;Second choice&lt;/li&gt; &lt;li&gt;Third choice&lt;/li&gt;&lt;/ul&gt; 例子1开始1234@register.inclusion_tag('results.html')def show_results(poll): choices = poll.choice_set.all() return &#123;'choices': choices&#125; results.html12345&lt;ul&gt;&#123;% for choice in choices %&#125; &lt;li&gt; &#123;&#123; choice &#125;&#125; &lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; 例子1结束 可使用takes_context=True直接访问上下文件中的数据1234567@register.inclusion_tag('link.html', takes_context=True)def jump_link(context): # 因为takes_context=True所以这里的context就是上下文，可以从里面拿想要的数据，如果有多个参数，方法里的第一个参数名必须是context return &#123; 'link': context['home_link'], 'title': context['home_title'], &#125; link.html1&lt;a href="&#123;&#123; link &#125;&#125;"&gt;&#123;&#123; title &#125;&#125;&lt;/a&gt;. 页面直接写1&#123;% jump_link %&#125; 位置参数和关键字参数和python语法一样123456@register.inclusion_tag('my_template.html')def my_tag(a, b, *args, **kwargs): warning = kwargs['warning'] profile = kwargs['profile'] ... return ... 1&#123;% my_tag 123 "abcd" book.title warning=message|lower profile=user.profile %&#125; 还有一个register.assignment_tag与register.simple_tag功能一样，不知道有什么特殊作用 使用表单一些表单输入自带有html5的验证，要禁用这些验证可以设置form标签的novalidate属性 is_bound可以判断一个表单是否具有绑定数据12345678# 未绑定表单f = ContactForm()data = &#123;'subject': 'hello', 'message': 'Hi there', 'sender': 'foo@example.com', 'cc_myself': True&#125;# 已绑定的表单f = ContactForm(data) 当表单通过is_valid()方法验证后，可以直接在form.cleaned_data中拿值，并且是已经转换好的python格式的数据，但仍然可以从request.POST直接访问到未验证的数据。 表单排列 表单属性字段html标签字段的lablehtml标签字段lable标签上的for值，也是字段标签上的id 隐藏字段列表显示的字段列表 错误信息不是特定字段的错误全部错误，一个字典字段错误 可从form从遍历出field有以下属性`Model或是Form上的label的值整个label标签，包含冒号字段的id字段的值字段的name，考虑表单的前缀字段的帮助文档字段的错误判断字段是否隐藏表单类中Field的实例，可以使用它来访问Field`属性，如1name.field.max_length 表单 API12345678# 未绑定表单f = ContactForm()data = &#123;'subject': 'hello', 'message': 'Hi there', 'sender': 'foo@example.com', 'cc_myself': True&#125;# 已绑定的表单f = ContactForm(data) 表单实例一但创建，数据不可更改 Form.clean()Form.is_valid()Form.errors Form.errors访问errors 属性可以获得错误信息的一个字典：12&gt;&gt;&gt; f.errors&#123;'sender': ['Enter a valid email address.'], 'subject': ['This field is required.']&#125; 在这个字典中，键为字段的名称，值为表示错误信息的Unicode 字符串组成的列表。错误信息保存在列表中是因为字段可能有多个错误信息。你可以在调用is_valid() 之前访问errors。表单的数据将在第一次调用is_valid() 或者访问errors 时验证。验证只会调用一次，无论你访问errors 或者调用is_valid() 多少次。这意味着，如果验证过程有副作用，这些副作用将只触发一次。 Form.errors.as_data() 返回一个字典，它映射字段到原始的ValidationError 实例 Form.errors.as_json(escape_html=False) 返回JSON 序列化后的错误。 Form.add_error(field, error) 这个方法允许在Form.clean() 方法内部或从表单的外部一起给字段添加错误信息Form.add_error() 会自动删除cleaned_data 中的相关字段 Form.has_error(field, code=None) 这个方法返回一个布尔值，指示一个字段是否具有指定错误code 的错误。当code 为None 时，如果字段有任何错误它都将返回True。若要检查非字段错误，使用NON_FIELD_ERRORS 作为field 参数。 Form.non_field_errors() 这个方法返回Form.errors 中不是与特定字段相关联的错误。它包含在Form.clean() 中引发的ValidationError 和使用Form.add_error(None, “…”) 添加的错误。 未绑定表单的行为验证没有绑定数据的表单是没有意义的，下面的例子展示了这种情况： 12345&gt;&gt;&gt; f = ContactForm()&gt;&gt;&gt; f.is_valid()False&gt;&gt;&gt; f.errors&#123;&#125; Form.initial1&gt;&gt;&gt; f = ContactForm(initial=&#123;'subject': 'Hi there!'&#125;) 这些值只显示在没有绑定的表单中，即使没有提供特定值它们也不会作为后备的值。优先级高于Form中的initial12345678910&gt;&gt;&gt; from django import forms&gt;&gt;&gt; class CommentForm(forms.Form):... name = forms.CharField(initial='class')... url = forms.URLField()... comment = forms.CharField()&gt;&gt;&gt; f = CommentForm(initial=&#123;'name': 'instance'&#125;, auto_id=False)&gt;&gt;&gt; print(f)&lt;tr&gt;&lt;th&gt;Name:&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="name" value="instance" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;Url:&lt;/th&gt;&lt;td&gt;&lt;input type="url" name="url" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;Comment:&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="comment" /&gt;&lt;/td&gt;&lt;/tr&gt; Form.has_changed()也有Field.has_changed()方法检查表单数据是否从初始数据发生改变当提交表单时，我们可以重新构建表单并提供初始值，这样可以实现比较：12&gt;&gt;&gt; f = ContactForm(request.POST, initial=data)&gt;&gt;&gt; f.has_changed() 如果request.POST 中的数据与initial 中的不同，has_changed() 将为True，否则为False。 计算的结果是通过调用表单每个字段的Field.has_changed() 得到的。 Form.fields从表单中访问字段是一个OrderedDict可你可以修改表单实例的字段来改变字段在表单中的表示：12345&gt;&gt;&gt; f.as_table().split('\n')[0]'&lt;tr&gt;&lt;th&gt;Name:&lt;/th&gt;&lt;td&gt;&lt;input name="name" type="text" value="instance" /&gt;&lt;/td&gt;&lt;/tr&gt;'&gt;&gt;&gt; f.fields['name'].label = "Username"&gt;&gt;&gt; f.as_table().split('\n')[0]'&lt;tr&gt;&lt;th&gt;Username:&lt;/th&gt;&lt;td&gt;&lt;input name="name" type="text" value="instance" /&gt;&lt;/td&gt;&lt;/tr&gt;' 注意不要改变base_fields 属性，因为一旦修改将影响同一个Python 进程中接下来所有的ContactForm 实例：1234&gt;&gt;&gt; f.base_fields['name'].label = "Username"&gt;&gt;&gt; another_f = CommentForm(auto_id=False)&gt;&gt;&gt; another_f.as_table().split('\n')[0]'&lt;tr&gt;&lt;th&gt;Username:&lt;/th&gt;&lt;td&gt;&lt;input name="name" type="text" value="class" /&gt;&lt;/td&gt;&lt;/tr&gt;' cleaned_data 始终只 包含表单中定义的字段，即使你在构建表单 时传递了额外的数据。cleaned_data 始终只 包含表单中定义的字段，即使你在构建表单 时传递了额外的数据。当表单合法时，cleaned_data 将包含所有字段的键和值，即使传递的数据不包含某些可选字段的值。 Form.cleaned_dataForm.as_pForm.as_ulForm.as_table Form.error_css_class Form.required_css_class在Form类下可以用上面两个属性定义错误样式和必填样式，没有默认值，required_css_class也会回在label标签上 Form.auto_id控制表单上的label和表单元素的id，值为True，False或字符串，支持%s占位符，表示当前字段名 如果auto_id 设置为任何其它的真值 —— 例如不包含%s 的字符串 —— 那么其行为将类似auto_id 等于True。默认情况下，auto_id 设置为’id_%s’。 Form.label_suffix默认为英文的: BoundField12345form = ContactForm()for boundfield in form: print(boundfield)# 或from['name'] BoundField.errorsBoundField.label_tag(contents=None, attrs=None, label_suffix=None)BoundField.css_classes()BoundField.value()提供初始值，会被绑定值覆盖BoundField.id_for_label Form.is_multipart()可判断表单是否需要multipart1234567&#123;% if form.is_multipart %&#125; &lt;form enctype="multipart/form-data" method="post" action="/foo/"&gt;&#123;% else %&#125; &lt;form method="post" action="/foo/"&gt;&#123;% endif %&#125;&#123;&#123; form &#125;&#125;&lt;/form&gt; 子类化表单时可通过设置None来删除从父类中继承过来的字段1234567891011&gt;&gt;&gt; from django import forms &gt;&gt;&gt; class ParentForm(forms.Form):... name = forms.CharField()... age = forms.IntegerField() &gt;&gt;&gt; class ChildForm(ParentForm):... name = None &gt;&gt;&gt; ChildForm().fields.keys()... ['age'] Form.prefix如果在页面中需要放多个相同的表单，可以设置表单的前缀12345678&gt;&gt;&gt; father = PersonForm()&gt;&gt;&gt; print(father.as_ul())&lt;li&gt;&lt;label for="id_first_name"&gt;First name:&lt;/label&gt; &lt;input type="text" name="first_name" id="id_first_name" /&gt;&lt;/li&gt;&lt;li&gt;&lt;label for="id_last_name"&gt;Last name:&lt;/label&gt; &lt;input type="text" name="last_name" id="id_last_name" /&gt;&lt;/li&gt;&gt;&gt;&gt; mother = PersonForm(prefix="mother")&gt;&gt;&gt; print(mother.as_ul())&lt;li&gt;&lt;label for="id_mother-first_name"&gt;First name:&lt;/label&gt; &lt;input type="text" name="mother-first_name" id="id_mother-first_name" /&gt;&lt;/li&gt;&lt;li&gt;&lt;label for="id_mother-last_name"&gt;Last name:&lt;/label&gt; &lt;input type="text" name="mother-last_name" id="id_mother-last_name" /&gt;&lt;/li&gt; 表单字段Field.has_change()检查字段的值是否从初始值发生改变 内建字段BooleanFieldWidget：CheckboxInput错误信息的键：required CharFieldWidget：TextInput错误信息的键：required`max_lengthmin_length` 接收两个可选参数 `max_lengthmin_length` ChoiceFieldWidtget：Select错误信息的键：required`invalid_choiceinvalid_choice错误消息可能包含%(value)s，它将被选择的选项替换掉。 接收一个额外的必选参数choices`是一个二元组组成的可迭代对象 TypeChoiceFieldWidget：Select错误信息的键：required`invalid_choice接收额外的参数choices是一个二元组组成的可迭代对象coerce接收一个参数并返回强制转换后的值的一个函数。例如内建的int、float、bool 和其它类型。默认为id 函数。注意强制转换在输入验证结束后发生，所以它可能强制转换不在 choices 中的值empty_value` 用于表示“空”的值。默认为空字符串；None 是另外一个常见的选项。注意这个值不会被coerce 参数中指定的函数强制转换，所以请根据情况进行选择 DateFieldWidget：DateInput错误信息的键：required`invalid接收一个可选参数input_formats一个格式的列表，用于转换一个字符串为datateim.date`对象默认为123[&apos;%Y-%m-%d&apos;, # &apos;2006-10-25&apos;&apos;%m/%d/%Y&apos;, # &apos;10/25/2006&apos;&apos;%m/%d/%y&apos;] # &apos;10/25/06&apos; 另外，如果你在设置中指定USE_L10N=False，以下的格式也将包含在默认的输入格式中：12345678[&apos;%b %d %Y&apos;, # &apos;Oct 25 2006&apos;&apos;%b %d, %Y&apos;, # &apos;Oct 25, 2006&apos;&apos;%d %b %Y&apos;, # &apos;25 Oct 2006&apos;&apos;%d %b, %Y&apos;, # &apos;25 Oct, 2006&apos;&apos;%B %d %Y&apos;, # &apos;October 25 2006&apos;&apos;%B %d, %Y&apos;, # &apos;October 25, 2006&apos;&apos;%d %B %Y&apos;, # &apos;25 October 2006&apos;&apos;%d %B, %Y&apos;] # &apos;25 October, 2006&apos; DateTimeFieldWidget：DateTimeInput错误信息的键：required`invalid接收一个可选参数input_formats一个格式的列表，用于转换一个字符串为datetime.datetime`对象默认为123456789[&apos;%Y-%m-%d %H:%M:%S&apos;, # &apos;2006-10-25 14:30:59&apos;&apos;%Y-%m-%d %H:%M&apos;, # &apos;2006-10-25 14:30&apos;&apos;%Y-%m-%d&apos;, # &apos;2006-10-25&apos;&apos;%m/%d/%Y %H:%M:%S&apos;, # &apos;10/25/2006 14:30:59&apos;&apos;%m/%d/%Y %H:%M&apos;, # &apos;10/25/2006 14:30&apos;&apos;%m/%d/%Y&apos;, # &apos;10/25/2006&apos;&apos;%m/%d/%y %H:%M:%S&apos;, # &apos;10/25/06 14:30:59&apos;&apos;%m/%d/%y %H:%M&apos;, # &apos;10/25/06 14:30&apos;&apos;%m/%d/%y&apos;] # &apos;10/25/06&apos; DecimalFieldWidget：当Field.localize是False时为NumberInput，否则为TextInput错误信息的键：required`invalidmax_valuemin_digitsmax_decimal_placesmax_whole_digitsmax_value和min_value错误信息可能包含%(limit_value)s，它们将被真正的限制值替换。类似地，max_digits、max_decimal_places和max_whole_digits错误消息可能包含%(max)s接收四个可选参数max_valuemin_valuemax_digits最大位数decimal_places`最大小数位 DurationFieldWidget：TextInput错误信息的键：required`invalid` EmailFieldWidget：EmailInput错误信息的键：required`invalid接收两个可选参数max_lengthmin_length` FileFieldWidget：ClearableFileInput错误信息的键：required`invalidmissingemptymax_length` 接收两个可选参数 `max_lengthallow_empty_file如果提供，这两个参数确保文件名的最大长度，而且即使文件内容为空时验证也会成功max_length错误信息表示文件名的长度。在错误信息中，%(max)d将替换为文件的最大长度，%(length)d` 将替换为当前文件名的长度 FilePathFieldWidget：Select错误信息的键：required`invalid_choice这个字段允许从一个特定的目录选择文件 接收五个参数path必须 想要列出的目录的绝对路径recursive可选 布尔值，默认为False，是否需要递归这个目录match可选 正则表达式表示一个模式，只有匹配这个表达式的名称才会允许作为选项allow_files可选 布尔值，默认为True，表示是否应该包含指定位置的文件，它和allow_folders必须有一个为Trueallow_folders可选 布尔值，默认为True，表示是否应该包含指定位置的目录，和allow_files必须有一个为True` FloatFieldWidget：当Field.localize是False 时为NumberInput，否则为TextInput错误信息的键：required`invalidmax_valuemin_value接收两个可选参数max_valuemin_value` ImageFieldWidget：ClearableFileInput错误信息的键：required`invalidmissingemptyinvalid_image` IntegerFieldWidget：当Field.localize是False时为NumberInput，否则为TextInput错误信息的键：required`invalidmax_valuemin_value接收两个可选参数max_valuemin_value` IPAddressField1.7弃用 GenericIPAddressFieldWidget：TextInput错误信息的键：required`invalid接收两个可选参数protocolunpack_ipv4` MultipleChoiceFieldWidget：SelectMultiple错误信息的键：required`invalid_choiceinvalid_list` TypedMultipleChoiceFieldNullBooleanFieldRegexFieldSlugFieldTimeFieldURLFieldUUIDField输出时需要.hex ComboField12345678&gt;&gt;&gt; from django.forms import ComboField&gt;&gt;&gt; f = ComboField(fields=[CharField(max_length=20), EmailField()])&gt;&gt;&gt; f.clean('test@example.com')'test@example.com'&gt;&gt;&gt; f.clean('longemailaddress@example.com')Traceback (most recent call last):...ValidationError: ['Ensure this value has at most 20 characters (it has 28).'] MultiValueFieldSplitDateTimeFieldModelChoiceField12345# A custom empty labelfield1 = forms.ModelChoiceField(queryset=..., empty_label="(Nothing)") # No empty labelfield2 = forms.ModelChoiceField(queryset=..., empty_label=None) ModelMultipleChoiceFieldWidgets处理文本输入的Widget TextInput NumberInput EmailInput URLInput PasswordInput HiddenInput DateInput DateTimeInput TimeInput Textarea 选择和复选框Widget CheckboxInput Select NullBooleanSelect SelectMultiple RadioSelect CheckboxSelectMultiple 文件上传Widget FileInput ClearableFileInput 复合Widget MultipleHiddenInput SplitDateTimeWidget SplitHiddenDateTimeWidget SelectDateWidget 从模型创建表单下面两种方法效果相同12345678author = Author(title='Mr')form = PartialAuthorForm(request.POST, instance=author)form.save()# orform = PartialAuthorForm(request.POST)author = form.save(commit=False)author.title = 'Mr'author.save() 显式定义的字段不会从对于的模型中获取属性，例如 max_length 或required。 如果你希望保持模型中指定的行为，你必须设置在声明表单字段时显式设置相关的参数。 例如，如果Article 模型像下面这样：1234class Article(models.Model): headline = models.CharField(max_length=200, null=True, blank=True, help_text="Use puns liberally") content = models.TextField() 而你想为headline 做一些自定义的验证，在保持blank 和help_text 值的同时，你必须定义这样定义ArticleForm： 1234567class ArticleForm(ModelForm): headline = MyFormField(max_length=200, required=False, help_text="Use puns liberally") class Meta: model = Article fields = ['headline', 'content'] 创建简单的表单或表单集可以使用modelform_factory()`modelformset_factory()`方法来新建。 启用字段的本地化功能¶ 默认情况下，ModelForm 中的字段不会本地化它们的数据。你可以使用Meta 类的localized_fields 属性来启用字段的本地化功能。123456&gt;&gt;&gt; from django.forms import ModelForm&gt;&gt;&gt; from myapp.models import Author&gt;&gt;&gt; class AuthorForm(ModelForm):... class Meta:... model = Author... localized_fields = ('birth_date',) 如果localized_fields 设置为&#39;__all__&#39;这个特殊的值，所有的字段都将本地化。 提供的初始值会覆盖从实例取得的值123456&gt;&gt;&gt; article = Article.objects.get(pk=1)&gt;&gt;&gt; article.headline'My headline'&gt;&gt;&gt; form = ArticleForm(initial=&#123;'headline': 'Initial headline'&#125;, instance=article)&gt;&gt;&gt; form['headline'].value()'Initial headline' 如果不需要很多自定义，可以直接使用工厂方法来生成表单类1234&gt;&gt;&gt; from django.forms.models import modelform_factory&gt;&gt;&gt; from myapp.models import Book&gt;&gt;&gt; BookForm = modelform_factory(Book, fields=("author", "title"))&gt; 123&gt;&gt;&gt; from django.forms import Textarea&gt;&gt;&gt; Form = modelform_factory(Book, form=BookForm,... widgets=&#123;"title": Textarea()&#125;) 1&gt;&gt;&gt; Form = modelform_factory(Author, form=AuthorForm, localized_fields=("birth_date",)) 表单集123&gt;&gt;&gt; from django.forms.models import modelformset_factory&gt;&gt;&gt; from myapp.models import Author&gt;&gt;&gt; AuthorFormSet = modelformset_factory(Author, fields=('name', 'title')) 使用model生成的formset默认带一个包含全部对象的querysetformset`save()`之后，会有新的属性123models.BaseModelFormSet.changed_objectsmodels.BaseModelFormSet.deleted_objectsmodels.BaseModelFormSet.new_objects max_num为最大的表单数，如果初始queryset长度比max_num，则按照queryset来，extra是可以额外添加的空表单的个数，但extra和queryset长度相加如果大于max_num，则extra和实例设置可能表现不一样，如queryset长度为2，max_num为4，extra不管是2还是5，最终表现出来都是2。1AuthorFormSet = modelformset_factory(Author, fields=('name',), max_num=4, extra=2) max_num默认只影响显示，不影响验证，如果需要影响验证添加validate_max=True即可 表单素材 ( Media 类)Form和Widget都可以定义素材 12345678from django import forms class CalendarWidget(forms.TextInput): class Media: css = &#123; 'all': ('pretty.css',) &#125; js = ('animations.js', 'actions.js') 使用CalendarWidget会自动引入下列资源123&lt;link href="http://static.example.com/pretty.css" type="text/css" media="all" rel="stylesheet" /&gt;&lt;script type="text/javascript" src="http://static.example.com/animations.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="http://static.example.com/actions.js"&gt;&lt;/script&gt; Widget会默认继承父类的素材，如果不想继承在Media里使用extend禁止。 动态定义12345class CalendarWidget(forms.TextInput): def _media(self): return forms.Media(css=&#123;'all': ('pretty.css',)&#125;, js=('animations.js', 'actions.js')) media = property(_media) 两个Media实例可以相加12345678910111213141516171819&gt;&gt;&gt; from django import forms&gt;&gt;&gt; class CalendarWidget(forms.TextInput):... class Media:... css = &#123;... 'all': ('pretty.css',)... &#125;... js = ('animations.js', 'actions.js') &gt;&gt;&gt; class OtherWidget(forms.TextInput):... class Media:... js = ('whizbang.js',) &gt;&gt;&gt; w1 = CalendarWidget()&gt;&gt;&gt; w2 = OtherWidget()&gt;&gt;&gt; print(w1.media + w2.media)&lt;link href="http://static.example.com/pretty.css" type="text/css" media="all" rel="stylesheet" /&gt;&lt;script type="text/javascript" src="http://static.example.com/animations.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="http://static.example.com/actions.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="http://static.example.com/whizbang.js"&gt;&lt;/script&gt; 表单Media12345678910111213141516&gt;&gt;&gt; class ContactForm(forms.Form):... date = DateField(widget=CalendarWidget)... name = CharField(max_length=40, widget=OtherWidget)...... class Media:... css = &#123;... 'all': ('layout.css',)... &#125; &gt;&gt;&gt; f = ContactForm()&gt;&gt;&gt; f.media&lt;link href="http://static.example.com/pretty.css" type="text/css" media="all" rel="stylesheet" /&gt;&lt;link href="http://static.example.com/layout.css" type="text/css" media="all" rel="stylesheet" /&gt;&lt;script type="text/javascript" src="http://static.example.com/animations.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="http://static.example.com/actions.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="http://static.example.com/whizbang.js"&gt;&lt;/script 表单集表单集控制max_nummin_numvalidate_maxvalidate_mincan_ordercan_delete 其中can_order`can_delete`默认以以下形式展现 如果是使用Model生成的表单集，如果delete后，在调用formset.save()会自动删除相应的数据，但如果调用了formset.save(commit=False)，则需要手动删除（1.6或更早版还是会自动删除）123&gt;&gt;&gt; instances = formset.save(commit=False)&gt;&gt;&gt; for obj in formset.deleted_objects:... obj.delete() 如果要兼容1.6或更早版，可以这么写12345678&gt;&gt;&gt; try:&gt;&gt;&gt; # For Django 1.7+&gt;&gt;&gt; for obj in formset.deleted_objects:&gt;&gt;&gt; obj.delete()&gt;&gt;&gt; except AssertionError:&gt;&gt;&gt; # Django 1.6 and earlier already deletes the objects, trying to&gt;&gt;&gt; # delete them a second time raises an AssertionError.&gt;&gt;&gt; pass 在表单集里添加额外的字段123456789101112131415&gt;&gt;&gt; from django.forms.formsets import BaseFormSet&gt;&gt;&gt; from django.forms.formsets import formset_factory&gt;&gt;&gt; from myapp.forms import ArticleForm&gt;&gt;&gt; class BaseArticleFormSet(BaseFormSet):... def add_fields(self, form, index):... super(BaseArticleFormSet, self).add_fields(form, index)... form.fields["my_field"] = forms.CharField() &gt;&gt;&gt; ArticleFormSet = formset_factory(ArticleForm, formset=BaseArticleFormSet)&gt;&gt;&gt; formset = ArticleFormSet()&gt;&gt;&gt; for form in formset:... print(form.as_table())&lt;tr&gt;&lt;th&gt;&lt;label for="id_form-0-title"&gt;Title:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="form-0-title" id="id_form-0-title" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;&lt;label for="id_form-0-pub_date"&gt;Pub date:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="form-0-pub_date" id="id_form-0-pub_date" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;&lt;label for="id_form-0-my_field"&gt;My field:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="form-0-my_field" id="id_form-0-my_field" /&gt;&lt;/td&gt;&lt;/tr&gt; 表单集对应的模版写法12345&lt;form method="post" action=""&gt; &lt;table&gt; &#123;&#123; formset &#125;&#125; &lt;/table&gt;&lt;/form&gt; 也可以手动渲染，不能缺少12345678&lt;form method="post" action=""&gt; &#123;&#123; formset.management_form &#125;&#125; &lt;table&gt; &#123;% for form in formset &#123;&#123; form &#125;&#125; &#123;% endfor &lt;/table&gt;&lt;/form&gt; 如果是手动渲染，can_order`can_delete`需要手动添加123456789101112&lt;form method="post" action=""&gt; &#123;&#123; formset.management_form &#125;&#125; &#123;% for form in formset &lt;ul&gt; &lt;li&gt;&#123;&#123; form.title &#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123; form.pub_date &#125;&#125;&lt;/li&gt; &#123;% if formset.can_delete &lt;li&gt;&#123;&#123; form.DELETE &#125;&#125;&lt;/li&gt; &#123;% endif &lt;/ul&gt; &#123;% endfor&lt;/form&gt; 在一个视图中使用多个FormSet需要回前缀prefix1234567891011121314151617181920from django.forms.formsets import formset_factoryfrom django.shortcuts import render_to_responsefrom myapp.forms import ArticleForm, BookForm def manage_articles(request): ArticleFormSet = formset_factory(ArticleForm) BookFormSet = formset_factory(BookForm) if request.method == 'POST': article_formset = ArticleFormSet(request.POST, request.FILES, prefix='articles') book_formset = BookFormSet(request.POST, request.FILES, prefix='books') if article_formset.is_valid() and book_formset.is_valid(): # do something with the cleaned_data on the formsets. pass else: article_formset = ArticleFormSet(prefix='articles') book_formset = BookFormSet(prefix='books') return render_to_response('manage_articles.html', &#123; 'article_formset': article_formset, 'book_formset': book_formset, &#125;) 表单验证和字段验证格式标准抛出单个错误12345raise ValidationError( _('Invalid value: %(value)s'), code='invalid', params=&#123;'value': '42'&#125;,) 招聘多个错误1234567891011# Goodraise ValidationError([ ValidationError(_('Error 1'), code='error1'), ValidationError(_('Error 2'), code='error2'),]) # Badraise ValidationError([ _('Error 1'), _('Error 2'),]) 创建一个新的表单字段添加默认验证1234567891011121314151617181920from django import formsfrom django.core.validators import validate_email class MultiEmailField(forms.Field): def to_python(self, value): "Normalize data to a list of strings." # Return an empty list if no input was given. if not value: return [] return value.split(',') def validate(self, value): "Check if value consists only of valid emails." # Use the parent's handling of required fields, etc. super(MultiEmailField, self).validate(value) for email in value: validate_email(email) Django 的设置django-admin 工具 当使用django-admin 时， 你可以设置只设置环境变量一次，或者每次运行该工具时显式传递设置模块。 例如（Unix Bash shell）：12export DJANGO_SETTINGS_MODULE=mysite.settingsdjango-admin runserver 例如（Windows shell）：12set DJANGO_SETTINGS_MODULE=mysite.settingsdjango-admin runserver 使用–settings 命令行参数可以手工指定设置：1django-admin runserver --settings=mysite.settings 使用下面的命令可以查询设置与默认设置的不同1python manage.py diffsettings 在django app中使用设置应使用以下导入方式1from django.conf import settings 注意，django.conf.settings 不是一个模块 —— 它是一个对象。所以不可以导入每个单独的设置：1from django.conf.settings import DEBUG # This won't work. 不要在应用运行时改变设置 完整列表设置(Settings)CSRF_COOKIE_SECURE=True只通过HTTPS传递cookie DATABASES[&#39;CONN_MAX_AGE&#39;]数据库连接的戚时间，默认为0（历史遗留行为），设置为None表示无限的持久连接DECIMAL_SEPARATOR类型数据的分隔符默认为点.DISALLOWED_USER_AGENTS编写正则表达式元组禁用代码访问，需要启用CommonMiddleware中间件INTERNAL_IPS设置公司内容的ip，在些ip列表中的ip可以访问admindoc下的书签 应用1234567# rock_n_roll/apps.py from django.apps import AppConfig class RockNRollConfig(AppConfig): name = 'rock_n_roll' verbose_name = "Rock ’n’ roll" 123# rock_n_roll/__init__.py default_app_config = 'rock_n_roll.apps.RockNRollConfig' AppConfig可配置的属性 AppConfig.name AppConfig.label AppConfig.verbose_name Appconfig.path AppConfig只读属性 AppConfig.module Appconfig.models_module AppConfig方法 AppConfig.get_models() AppConfig..get_model(model_name) AppConfigevaluate.ready() 123&gt;&gt;&gt; from django.apps import apps&gt;&gt;&gt; apps.get_app_config('admin').verbose_name'Admin' APP apps.ready apps.get_app_configs() apps.get_app_config(app_label) apps.is_installed(app_name) apps.get_model(app_label, model_name) Django异常核心异常django.core.exceptions ObjectDoesNotExist对象不存在DoesNotExist的基类对ObjectDoesNotExist的try/except会为所有模型捕获到所有DoesNotExist 异常123456from django.core.exceptions import ObjectDoesNotExisttry: e = Entry.objects.get(id=3) b = Blog.objects.get(id=1)except ObjectDoesNotExist: print("Either the entry or blog doesn't exist.") FieldDoesNotExist当被请求的字段在模型或模型的父类中不存在时，FieldDoesNotExist异常由模型的 _meta.get_field()方法抛出 MultipleObjectsReturned查询时，预期只有一个对象，但是返回了多个对象会抛出此异常 SuspiciousOperation当用户进行的操作在安全方面可疑的时候，抛出此异常，例如，篡改cookie子类 DisallowedHost DisallowedModelAdminLookup DisallowedModelAdminToField DisallowedRedirect InvalidSessionKey SuspiciousFileOperation SuspiciousMultipartForm SuspiciousSession PermissionDenied当用户不被允许来执行请求的操作时产生 ViewDoesNotExist当请求的视图不存在时抛出此异常 MiddlewareNotUsed当中间件没有在服务器配置中出现时，抛出此异常 ImproperlyConfigureddjango配置不当时抛出此异常，如settings.py中的值不正确或者不可解析 FieldError当模型上的字段出现问题时，抛出此异常，由以下原因造成： 模型中的字段与抽象基类中的字段重名 排序造成了一个死循环 关键词不能由过滤器参数解析 字段不能由查询参数中的关键词决定 连接（join）不能在指定对象上使用 字段名称不可用 查询包含了无效的order_by参数 ValidationError当表单或模型字段验证失败时抛出此异常 NON_FIELD_ERRORS在表单或者模型中不属于特定字段的ValidationError被归类为NON_FIELD_ERRORS URL解析器异常 Resolver404django.http.Http404的子类当向resolve传递的路径不能匹配到对应视图时抛出此异常 NoReverseMatch当你的URLconf中的一个匹配的URL不能基于提供的参数识别时，抛出此异常 数据库异常数据库异常由django.db导入 Error InterfaceError DatabaseError DataError OperationalError IntegrityError InternalError ProgrammingError NotSupportedError HTTP异常HTTP异常由django.http导入 UnreadablePostError用户取消上传时抛出此异常 事务异常事务异常定义由django.db.transaction导入 测试框架异常由DJango django.test 包提供的异常 RedirectCycleError当测试客户端检测到重定向的循环或者过长的链时抛出此异常 Python异常Django在适当的时候也会抛出Python的内建异常 django-admin and manage.py dumpdata该命令将所有与被命名应用相关联的数据库中的数据输出到标准输出。如果在dumpdate命令后面未指定Django应用名，则Django项目中安装的所有应用的数据都将被dump到fixture中dumpdata --output data.json flus清空数据库，重新装载初始数据 --noinput --database --no-initial-data inspectdb根据数据库结构生成model1python manage.py inspectdb &gt; models.py loaddata导入fixture数据 runserver启动本地上一个轻量级的Web服务器，默认多线程--noreload禁用自动重新载入--nothreading禁用多线程 1runserver 0.0.0.0:80 添加自定义的命令向应用下添加management/commands目录，Django会为此目录下的所有没有带下划线开头的python模块都注册一个manage.py命令。在Python 2上，请确保management和management/commands两个目录都包含__init__.py 文件。 12345678910111213141516171819202122from django.core.management.base import BaseCommand, CommandErrorfrom polls.models import Poll class Command(BaseCommand): help = 'Closes the specified poll for voting' def add_arguments(self, parser): # 命令行接收一个或多个poll_id值 # parser.add_argument('poll_id', nargs='+', type=int) def handle(self, *args, **options): for poll_id in options['poll_id']: try: poll = Poll.objects.get(pk=poll_id) except Poll.DoesNotExist: raise CommandError('Poll "%s" does not exist' % poll_id) poll.opened = False poll.save() self.stdout.write('Successfully closed poll "%s"' % poll_id)]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>文档</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django REST framework之版本号version]]></title>
    <url>%2F2016%2F01%2F28%2Fdjango-rest-framework%E4%B9%8B%E7%89%88%E6%9C%AC%E5%8F%B7version%2F</url>
    <content type="text"><![CDATA[drf支持以下形式传输版本号 header 123GET /bookings/ HTTP/1.1Host: example.comAccept: application/json; version=1.0 URL Path 123GET /v1/bookings/ HTTP/1.1Host: example.comAccept: application/json 1234567urlpatterns = [ url( r&apos;^(?P&lt;version&gt;(v1|v2))/bookings/$&apos;, bookings_list, name=&apos;bookings-list&apos; ),] Namespace 123GET /v1/something/ HTTP/1.1Host: example.comAccept: application/json 1234urlpatterns = [ url(r&apos;^v1/bookings/&apos;, include(&apos;bookings.urls&apos;, namespace=&apos;v1&apos;)), url(r&apos;^v2/bookings/&apos;, include(&apos;bookings.urls&apos;, namespace=&apos;v2&apos;))] Host Name 123GET /bookings/ HTTP/1.1Host: v1.example.comAccept: application/json Query Parameter 123GET /something/?version=0.1 HTTP/1.1Host: example.comAccept: application/json drf默认是关闭版本控制功能，如需要开启，可在settings.py里添加对应的设置123456789REST_FRAMEWORK = &#123; …… 'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.AcceptHeaderVersioning', # 'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.URLPathVersioning', # 'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.NamespaceVersioning', # 'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.HostNameVersioning', # 'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.QueryParameterVersioning', ……&#125; 当然，你也可以为每个视图单独添加，不过不建议这么做12class ProfileList(APIView): versioning_class = versioning.QueryParameterVersioning 开启版本控制之后，就可以从request取得版本号request.version（当然你settings.py里配置的是什么方式，就用什么方式传版本号，这样就才可以从request里获取到版本号）1234def get_serializer_class(self): if self.request.version == 'v1': return AccountSerializerVersion1 return AccountSerializer 启动版本控制后，url逆向解析方法需要传入request参数123from rest_framework.reverse import reverse reverse('bookings-list', request=request) 如果是使用Namespace时的版本控制，因为配置了DEFAULT_VERSIONING_CLASS，所以设置view_name时不需要添加v1:前缀，见django rest framework入门笔记.md 最后在设置里添加以下全局设置来控制能访问的版本12'DEFAULT_VERSION': None, #默认版本，request里没有版本信息时，使用的版本，默认为None'ALLOWED_VERSIONS': [None, 'v1', 'v2'], #允许访问的版本，如果访问的版本不在列表中，则会抛出异常 也可以为每个视图单独设置12345678910from rest_framework.versioning import URLPathVersioningfrom rest_framework.views import APIView class ExampleVersioning(URLPathVersioning): default_version = ... allowed_versions = ... version_param = ... class ExampleView(APIVIew): versioning_class = ExampleVersioning]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>restful</tag>
        <tag>api</tag>
        <tag>version</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[curl常用命令]]></title>
    <url>%2F2015%2F12%2F17%2Fcurl%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[curl是利用URL语法在命令行方式下工作的开源文件传输工具。它被广泛应用在Unix、多种Linux发行版中，并且有DOS和Win32、Win64下的移植版本。 访问url并输出结果1curl http://www.example.com 传递参数默认curl使用GET方式请求数据，这种方式下直接通过URL传递数据可以通过 –data/-d 方式指定使用POST方式传递数据12345678# GETcurl -u username https://api.github.com/user?access_token=XXXXXXXXXX# POSTcurl -u username -d &quot;param1=value1&amp;param2=value&quot; https://api.github.com# 也可以指定一个文件，将该文件中的内容当作数据传递给服务器端curl -d @filename https://github.api.com/authorizations 注：默认情况下，通过POST方式传递过去的数据中若有特殊字符，首先需要将特殊字符转义在传递给服务器端，如value值中包含有空格，则需要先将空格转换成%20，如：1curl -d &quot;value%201&quot; http://hostname.com 在新版本的CURL中，提供了新的选项 –data-urlencode，通过该选项提供的参数会自动转义特殊字符。1curl --data-urlencode &quot;value 1&quot; http://hostname.com 指定请求方式除了使用GET和POST协议外，还可以通过 -X 选项指定其它协议，如：1curl -I -X DELETE https://api.github.com 设置请求头信息1curl -H &apos;Accept-Language: zh&apos; http://cnn.com -H或被多次指定1curl -H &apos;Host: 157.166.226.25&apos;-H &apos;Accept-Language: zh&apos;-H &apos;Cookie: ID=1234&apos; http://cnn.com 对于”User-Agent”, “Cookie”, “Host”这类标准的HTTP头部字段，通常会有另外一种设置方法。curl命令提供了特定的选项来对这些头部字段进行设置：-A (or –user-agent): 设置 “User-Agent” 字段.-b (or –cookie): 设置 “Cookie” 字段.-e (or –referer): 设置 “Referer” 字段.12curl -H &quot;User-Agent: my browser&quot; http://cnn.comcurl -A &quot;my browser&quot; http://cnn.com 查看响应头信息1curl -I http://www.baidu.com 提交表单1curl --form &quot;fileupload=@filename.txt&quot; http://hostname/resource 访问url并奖结果保存到本地文件中-o: 将文件保存为命令行中指定的文件名到本地-O: 使用url中默认的文件名保存文件到本地12345curl -o index.html http://www.example.com# 或curl http://www.baidu.com &gt; index.html# 在windows上没成功curl -O http://www.example.com 忽略证书错误工作中，经常需要用自签的假证书搭建开发环境。cURL在遇到证书错误时罢工，使用 -k 参数就可以让它不做证书校验。1curl -k https://www.example.com 获取重定向后的页面如果url重定向的话，curl默认是不会去获取重定向后的url页面的，使用-L可进行强制重定向1curl -L http://www.example.com 发送压缩的请求cURL提供了一个 –compress 参数，可以用来发送支持压缩的请求。但使用了–compress之后，虽然传输过程是压缩的，cURL的输出还是解压之后的，难以看到效果。 自己写一个 Accept-Encoding 字段在头信息中。1curl -H &quot;Accept-Encoding: gzip&quot; http://www.kuqin.com/ 如果直接运行上面的命令，会得到一堆乱码，因为cURL输出的内容，是压缩后的数据。不妨在后面接一个gunzip试试。12# 使用gunzip解压curl -H &quot;Accept-Encoding: gzip&quot; http://www.kuqin.com/ | gunzip 使用gunzip解压之后，信息又被还原了。 断点续传通过使用-C选项可对大文件使用断点续传功能12345# 未下载完成即中断该进程curl -o a.zip http://www.example.com/bigfile.zip# 后面可以通过-C来继续下载curl -C -o a.html http://www.example.com/bigfile.zip 下载限速使用-limit-rate进行限速12# 限速为100k/scurl --limit-rate 1000k -o a.zip http://www.example.com/bigfile.zip 根据文件修改时间来判断是否进行下载12# 若文件的修改时间在2011/12/11之后，则下载curl -z 21-Dec-11 http://www.example.com/bigfile.zip 授权在访问需要授权的页面时，可通过-u来提供用户名和密码进行授权1curl -u username:password http://www.example.com ftp操作123456789101112131415# 列出指定目录下的所有文件curl -u ftpuser:ftppw -O ftp://ftp_server/public_html/# 下载文件curl -u ftpuser:ftppw -Oftp://ftp_server/public_hmtl/bigfile.zip# 上传文件curl -u ftpuser:ftppw -T myfile.txt ftp://ftp_server/public_html/# 上传多个文件curl -u ftpuser:ftppw -T &quot;&#123;myfile1.txt, myfile2.txt&#125;&quot; ftp://ftp_server/public_html/# 从标准输入获取内容保存到服务器的指定文件中curl -u ftpuser:ftppw -T - ftp://ftp_server/public_html/1.txt 设置代理1curl -x proxyserver.com:1080 http://www.example.com 保存与使用网站的cookie信息12345# 将网站的cookies信息保存到example_cookies文件中curl -D example_cookies http://www.example.com# 使用cookies信息访问urlcurl -b example_cookies http://www.example.com/user/]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多说评论UA显示测试]]></title>
    <url>%2F2015%2F11%2F15%2Fduoshuo-comments-ua%2F</url>
    <content type="text"><![CDATA[多说评论UA显示测试]]></content>
  </entry>
  <entry>
    <title><![CDATA[Django字段选项related_name和related_query_name]]></title>
    <url>%2F2015%2F10%2F20%2Fdjango%E5%AD%97%E6%AE%B5%E9%80%89%E9%A1%B9related-name%E5%92%8Crelated-query-name%2F</url>
    <content type="text"><![CDATA[data123456789sqlite&gt; select * from author;id name age1 jim 122 tom 11sqlite&gt; select * from book;id name author_id1 learn java 12 learn python 13 learn c++ 2 models.py12345678910111213# -*- coding: UTF-8 -*-from __future__ import unicode_literalsfrom django.db import models# Create your models here.class Author(models.Model): name = models.CharField(verbose_name='姓名', max_length=50) age = models.IntegerField(verbose_name='年龄')class Book(models.Model): name = models.CharField(verbose_name='书名', max_length=100) author = models.ForeignKey(Author, verbose_name='作者') 执行语句12345&gt;&gt;&gt; Author.objects.filter(book__name=&apos;learn java&apos;)[&lt;Author: jim&gt;]&gt;&gt;&gt; author = Author.objects.get(pk=1)&gt;&gt;&gt; author.book_set.all()[&lt;Book: learn java&gt;, &lt;Book: learn python&gt;] 假如把类Book改成这样123class Book(models.Model): name = models.CharField(verbose_name=&apos;书名&apos;, max_length=100) author = models.ForeignKey(Author, verbose_name=&apos;作者&apos;, related_name=&apos;bs&apos;, related_query_name=&apos;b&apos;) 那么上面查询代码就应该写成这样12345&gt;&gt;&gt; Author.objects.filter(b__name=&apos;learn java&apos;)[&lt;Author: jim&gt;]&gt;&gt;&gt; author = Author.objects.get(pk=1)&gt;&gt;&gt; author.bs.all()[&lt;Book: learn java&gt;, &lt;Book: learn python&gt;] 如果book表里有两个字段都外键关联author表，这时related_name就非常有用了。]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git stash的简单运用]]></title>
    <url>%2F2015%2F10%2F20%2Fgit-stash%E7%9A%84%E7%AE%80%E5%8D%95%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[当我们在分支上改代码改到一半时，突然项目发现了一个bug需要修复，这时需要切换到另一个分支进行修改，以前的做法可能是把工作区改到一半的代码先commit，然后切换分支修复bug，再切换回来继续写代码，但这样会生成很多不必要的提交，这时你就需要使用git stash命令。git stash命令可将工作区的改动存储git栈，运行git stash之后，可以再运行git status -s验证下发现目录和上交commit时是一致的，没有任何修改，这时你就可以切换到其它分支进行工作，当你完成工作后，再切换回来，使用git stash pop可以从Git栈中读取最近一次保存的内容，恢复到工作区。 1234567git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。git stash save &quot;message&quot;: 备份当前的工作区的内容，并添加备注信息git stash list: 显示git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。git stash pop stash@&#123;0&#125;: 从git栈中读取并恢复工作区，然后删除对应的记录，默认恢复最新的（stash@&#123;0&#125;为最新）git stash apply stash@&#123;0&#125;: 同git stash pop，但不会删除对应的记录git stash drop: 删除最新的一个备份git stash clear: 清空git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。 参考http://www.tuicool.com/articles/rUBNBvI及git stash --help]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git patch的简单运用]]></title>
    <url>%2F2015%2F10%2F15%2Fgit-patch%E7%9A%84%E7%AE%80%E5%8D%95%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[生成PATCH往前n个提前内容的patch1git format-patch -n 某个commit（含）的及之前的n-1次提交的patch1git format-patch -n SHA 某个commit的patch1git format-patch -1 SHA 当前分支所有超前master提交的patch1git format-patch -M master 两个commit之间的所有patch（不包含较早SHA1提交的内容）1git format-patch SHA1...SHA1 某个commit之后的所有patch1git format-patch -s SHA 应用PATCH检查patch1git apply --stat xxx.patch 检查能否应用成功1git apply --check xxx.patch 打补丁1git am -s xxx.patch 如果有冲突，整个PATCH都不会被集成，接来来解决冲突问题123456# 把没有冲突的文件先合并了，剩下有冲突的作了标记git apply PATCH --reject# 这里手动解决冲突# 把解决冲突的和PATCH里新加的文件全部add进来，因为git am并不会改变indexgit add FIXED_FILESgit am --resolved 参考http://blog.csdn.net/daydring/article/details/42676987]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Material Design资源]]></title>
    <url>%2F2015%2F10%2F15%2Fmaterial-design%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[Material Design是谷歌在Google I/O 2014推出了全新的设计语言，并荣获2014年的用户体验最佳贡献金奖。 更新记录2015-10-15 初稿 演示视频 Material Design 文档官方 http://www.google.com/design/spec/material-design/introduction.html Material Design 中文版（官网翻译而来） 阅读: http://wiki.jikexueyuan.com/project/material-design/GitHub: https://github.com/1sters/material_design_zh_2PDF: http://pan.baidu.com/s/1fr1gi Material Design 中文版（官网翻译而来） 阅读: http://design.1sters.com/ （已关停）GitHub: https://github.com/1sters/material_design_zh Google Material Design 正體中文版（官网翻译而来） 阅读: https://www.gitbook.com/book/wcc723/google_design_translate/detailsGitHub: https://github.com/Wcc723/google_design_translatePDF: http://pan.baidu.com/s/1dD8X1Zj Material Design非官方中文指导手册 PDF: http://pan.baidu.com/s/1mg3P45i Android资源资源大合集https://github.com/lightSky/Awesome-MaterialDesign 十大Material Design开源项目http://www.csdn.net/article/2014-11-21/2822753-material-design-libs/1 图标Material icons guide 主页: http://google.github.io/material-design-icons/GitHub: https://github.com/google/material-design-icons 网页框架Angular Material（控件最全，样式不错，交互动态效果多） 主页: https://material.angularjs.org/GitHub: https://material.angularjs.org/ material ui（控件较多，样式不错，交互动态效果多） 主页: http://material-ui.com/GitHub: https://github.com/callemall/material-ui bootstrap-material-design（控件数量还行，样式较好，交互动态效果还行，Demo里部分样式有错位问题） 主页: http://fezvrasta.github.io/bootstrap-material-design/GitHub: http://fezvrasta.github.io/bootstrap-material-design/ muicss（控件较少，样式普通，交互动态效果少）（体积小，css+js 11.4k） 主页: https://www.muicss.com/GitHub: https://github.com/muicss/mui MaterializeCss（控件数量还行，样式较好，交互动态效果还行） 主页: http://materializecss.com/GitHub: https://github.com/Dogfalo/materialize bootswatch里的parper主题 主页: http://bootswatch.com/paper/GitHub: https://github.com/thomaspark/bootswatch jQuery Mobile Material Theme（控件较少，样式普通，无交互动态效果） 主页: http://store.ququplay.com/]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Material Design</tag>
        <tag>网页框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2015%2F09%2F11%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[之前写过一篇Git命令使用指南，但感觉那个写的太乱，不接地气，有时我自己找一个命令都难找，所以今天写一篇文章整理一些比较基础的，但又不常用的一些命令，后面会慢慢更新。 提交1234# 把所有已跟踪的文件添加到暂存区git add -u# 把所有已跟踪并有更新的文件提交到本地仓库git commit -am "update message" 列出分支123456789# 列出本地分支git branch或git branch -v# 列出本地和远程所有分支git branch -a或git branch -va 删除分支1234567# 删除本地分支git branck -D/-d &lt;branch&gt;# 删除远程分支，注意冒号前有空格git push origin :&lt;分支名&gt;# 等价于git push origin -d &lt;branch&gt; 推送分支12345678# 推送当前分支到默认remote上，remote上没有对应分支则自动创建git push# 推送当前分支到指定remote，remote上没有对应分支则自动创建git push &lt;remote&gt;# 推送到指定分支到remote的指定分支上git push &lt;remote&gt; &lt;remote_branch&gt;:&lt;loclal_branch&gt; 拉取远程分支到本地1git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt; 或1git checkout --track &lt;remote&gt;/&lt;branch&gt; 撤消提交（未push情况下）123git reset --mixed &lt;SHA1&gt; # 此SHA1之后的commit全部撤消，并回退index，工作空间代码不变，--mixed可省略git reset --soft &lt;SHA1&gt; # 此SHA1之后的commit全部撤消，工作空间代码和index不变git reset --hard &lt;SHA1&gt; # 此SHA1之后的commit全部撤消，工作空间代码和index全部退回 查看commit记录1git log --oneline -n # 单行显示最后n个commit的记录 本地分支和远程分支做关联1git branch --set-upstream-to=&lt;remote&gt;/&lt;remote_branch&gt; &lt;loclal_branch&gt; 推送本地当前新分支到远程1git push -u origin &lt;branch_name&gt; 查看日志12345678910# 当前分支日志git log# 所有本地分支日志git log --all# 指定本地分支日志git log &lt;branch_name&gt;# 指定远程分支日志git log origin/&lt;branch_name&gt;# 所有远程分支日志git log --all origin 重命名分支1git branch (-m | -M) [&lt;old-branch&gt;] &lt;new-branch&gt;]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django内置的flatpages应用]]></title>
    <url>%2F2015%2F09%2F08%2Fdjango%E5%86%85%E7%BD%AE%E7%9A%84flatpages%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[不知道大家平时写网站时类似「关于页面」，「用户协议」这类页面是如何处理的。这里列出了这类页面的两个特点： 页面数据简单（不会有很多动态数据展示）; 有更新但频率不高; 如果要为这类页面展示建立多个数据表，显然是很浪费的行为，但如果直接写成静态页面文件，更新又比较很麻烦，这时候就可以使用flatpages来解决这类问题了。 django.contrib.flatpages是Django的内置app，用于添加更新的一些简单的页面，具体设置，请继续查看以下步骤。 安装首先确保INSTALLED_APPS中已经存在django.contrib.sites，因为django.contrib.flatpages依赖于此包。settings.py12345678INSTALLED_APPS = ( # ... 'django.contrib.sites', 'django.contrib.flatpages',)# ...# 如果没有设置`SITE_ID`值，则需要设置，这里直接设置为1SITE_ID = 1 执行python manage.py migrate建表 配置路由配置可先以有多种形式urls.py第一种（需放在最后，推荐）1234from django.contrib.flatpages import viewsurlpatterns += [ url(r&apos;^(?P&lt;url&gt;.*/)$&apos;, views.flatpage),] 第二种（每个页面都需要写一个url，推荐）12345from django.contrib.flatpages import viewsurlpatterns = [ url(r&apos;^about-us/$&apos;, views.flatpage, &#123;&apos;url&apos;: &apos;/about-us/&apos;&#125;, name=&apos;about&apos;), url(r&apos;^license/$&apos;, views.flatpage, &#123;&apos;url&apos;: &apos;/license/&apos;&#125;, name=&apos;license&apos;),] 或者，如果你不想配置路由，还有一种更简单的方法，直接在settings.py的里添加中间件1234MIDDLEWARE_CLASSES = ( # ... &apos;django.contrib.flatpages.middleware.FlatpageFallbackMiddleware&apos;,) 为确保配置生效，保险的方法是把django.contrib.flatpages.middleware.FlatpageFallbackMiddleware放在最后一行 管理flatpages默认的你可以登录超级管理员后台（如果开启），找到Flat pages，进去点击添加，可以看到可配置的选项有，URL Title Content Site Enable comments Registration required Template name 数据项说明 URL: 页面所处的 URL，不包括域名，但是包含前导斜杠 (例如 /about/contact/ ) Title: 页面的标题，框架不对它作任何特殊处理。由你通过模板来显示它 Content: 页面的内容 (即 HTML 页面)，框架不会对它作任何特别处理。由你负责使用模板来显示 Site: 页面放置的站点，该项设置集成了 Django 多站点框架 Enable comments: 是否允许该简单页面使用评论，框架不对此做任何特别处理。你可在模板中检查该值并根据需要显示评论窗体 Registration required: 是否注册用户才能查看此简单页面，该设置项集成了 Djangos 验证/用户框架，该框架于第十二章详述。 Template name: 用来解析该简单页面的模板名称，这是一个可选项，如果未指定模板或该模板不存在，系统会退而使用默认模板 flatpages/default.html（我在Django1.8.4里死活没找到，只好自己写好一个扔进去） 当添加相应的数据后，剩下工作就交给flatpages吧，如果你是使用中间件形式的，则flatpages会在配置完所有urls.py后，没有找到配置到对应的URL，才会到flatpages中查找，如果还是找不到，则会引发Http404异常，即FlatpageFallbackMiddleware只在404时会被激活，而不会在500或其它错误响应时被激活。 如果你需要自己定制，则可以针对django/contrib/flatpages/models.py自己写增删改方法就可以。models.py12345678910111213141516171819202122232425262728class FlatPage(models.Model): url = models.CharField(_('URL'), max_length=100, db_index=True) title = models.CharField(_('title'), max_length=200) content = models.TextField(_('content'), blank=True) enable_comments = models.BooleanField(_('enable comments'), default=False) template_name = models.CharField(_('template name'), max_length=70, blank=True, help_text=_( "Example: 'flatpages/contact_page.html'. If this isn't provided, " "the system will use 'flatpages/default.html'." ), ) registration_required = models.BooleanField(_('registration required'), help_text=_("If this is checked, only logged-in users will be able to view the page."), default=False) sites = models.ManyToManyField(Site) class Meta: db_table = 'django_flatpage' verbose_name = _('flat page') verbose_name_plural = _('flat pages') ordering = ('url',) def __str__(self): return "%s -- %s" % (self.url, self.title) def get_absolute_url(self): # Handle script prefix manually because we bypass reverse() return iri_to_uri(get_script_prefix().rstrip('/') + self.url) 模板默认模板路径为flatpages/default.html123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;&#123;&#123; flatpage.title &#125;&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&#123;&#123; flatpage.content &#125;&#125;&lt;/body&gt;&lt;/html&gt; 在实际应用中，我们不太可能会使用默认的模板，你可能需要自己写一个漂亮模板，比如有一个头部和底部，头部可能还需要添加requeset.user显示用户信息等。 高级应用获取flatpages实例列表12&#123;% load flatpages %&#125;&#123;% get_flatpages as flatpages %&#125; 获取当前用户能打开的flatpages实例列表12&#123;% load flatpages %&#125;&#123;% get_flatpages for request.user as about_pages %&#125; 获取链接以/about/为开头的flatpages实例列表12&#123;% load flatpages %&#125;&#123;% get_flatpages &apos;/about/&apos; as about_pages %&#125; 上面两种也可以组合使用12&#123;% load flatpages %&#125;&#123;% get_flatpages &apos;/about/&apos; for someuser as about_pages %&#125; 生成sitemaps.xml123456789101112from django.conf.urls import urlfrom django.contrib.flatpages.sitemaps import FlatPageSitemapfrom django.contrib.sitemaps.views import sitemap urlpatterns = [ # ... # the sitemap url(r&apos;^sitemap\.xml$&apos;, sitemap, &#123;&apos;sitemaps&apos;: &#123;&apos;flatpages&apos;: FlatPageSitemap&#125;&#125;, name=&apos;django.contrib.sitemaps.views.sitemap&apos;),] 容易踩的坑最好把settings.py里的APPEND_SLASH设置为Ture， 这样不管是/about-us还是/about-us/都可以访问到。 参考资料 https://docs.djangoproject.com/en/1.8/ref/contrib/flatpages/ http://djangobook.py3k.cn/2.0/chapter16/]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Synergy实现多台电脑共享一套键鼠]]></title>
    <url>%2F2015%2F08%2F29%2F%E4%BD%BF%E7%94%A8synergy%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E5%85%B1%E4%BA%AB%E4%B8%80%E5%A5%97%E9%94%AE%E9%BC%A0%2F</url>
    <content type="text"><![CDATA[因为家里有一台台式和一台笔记本，台式Windows10为日常使用，笔记本Ubuntu&amp;Windows7，以前一直在Windows上敲代码，现在正转向Ubuntu，但家里桌子上摆放两台电脑已经有点挤了，如果再来两套键鼠那就成二手电脑配件甩卖铺了，所以上网查了下看看有没有软件能实现两台电脑共享一套键盘的，还真找到了一款叫Synergy的软件，支持Windows, Mac OS X, Linux三大系统，软件是下载收费，使用使用免费，官网上标明基础版$10，高级版$29。下面我说说我自己的配置过程。 安装在Ubuntu里打开终端，输入以下命令进行安装1sudo apt-get install synergy 在Windwos上双击安装。 Ubuntu我安装的是1.6.2，Windwos上是1.7.4 x64 配置服务器设置 synergy需要一台电脑做为服务端，其它电脑做为客户端来连接服务端。本来是我想选择Ubuntu做为服务端的，但设置好后链接失败提示为WARNING: failed to connect to server: incompatible client 1.5，似乎是不兼容，但我的客户端版本是1.6.2不是1.5啊，所以作罢，只得选用Windwos来做服务端。 我们选用Windwos来做服务端，在Windwos打开软件，选择「server」；Synergy-Windows服务端配置首页.png) 点击「设置服务端」进行添加客户端操作；Synergy-Windows服务端添加客户端-01.png) 从右上角手动电脑图标到下方的格子里，这里的格式位置对应你当前几台电脑的实际的以我把电脑图标拖到中间左侧的格子里；Synergy-Windows服务端添加客户端-02.png) 双击电脑图标进行编辑，这里我们只需要输入客户端电脑的计算机名，其它都默认；Synergy-Windows服务端添加客户端-03.png) 设置好后点击再次ok，回到设置首页，点击「开始」启动服务端；Synergy-Windows服务端启动.png) 客户端设置 客户端比较简单，在Ubuntu上打开Synergy，选择「Client」，在Server IP里输入服务端的IP，点击「Start」即可；Synergy-Ubuntu客户端配置首页.png) 开机自启要在Ubuntu开机在登录界面前启动synergy，编辑/etc/lightdm/lightdm.conf文件添加display-setup-script=/usr/bin/synergyc 192.168.9.102，把192.168.9.102换成你自己的synergy服务端IP。 完成到这里你就会发现你可鼠标可以在两个电脑屏幕上移动了，像我刚才配置的是在Windows左侧添加了Ubuntu，所以当我在Windows上把鼠标向左移动，并移到边界，再继续左移时，鼠标就会出现在Ubuntu屏幕上，键盘的行为跟随鼠标的，即鼠标在哪个屏幕，键盘输入就对应哪个屏幕的系统。 网上说Synergy支持在不同电脑间复制粘贴，目前我自己没有试成功，有知道朋友可以和说。 相关项目主页：https://github.com/synergy/synergy 更新记录2015-08-29 初稿2015-09-03 补充Ubuntu客户端自启明说]]></content>
      <categories>
        <category>优化辅助</category>
      </categories>
      <tags>
        <tag>Synergy</tag>
        <tag>共享</tag>
        <tag>键盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu从14.10升级到15.04]]></title>
    <url>%2F2015%2F08%2F29%2Fubuntu%E4%BB%8E14-10%E5%8D%87%E7%BA%A7%E5%88%B015-04%2F</url>
    <content type="text"><![CDATA[ubuntu-15.04-logo.jpg) ubuntu15.04已经发布几个月了，今天准备把家里的笔记本升级下，在这记录下，因为笔记本是14.10的所以下面内容只适用于从14.10升级到15.04的，如果你的系统是14.04，则需要先升级到14.10然后再升级到15.04。 先检查系统更新，如果有则进行更新，在终端中输入以下命令1sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade 然后检查是否有可用的版本1sudo update-manager -d 回车后会弹出软件更新器，等检查完成后点击升级，后面还会出来很多个确认对话框，一路确定下去就好。 最后点击开始升级，然后就等着更新自动下载更新吧。ubuntu-14.10-15.04-01.png) 更新完后重启系统即可完成升级。ubuntu-15.04-info.png)]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XY-Problem]]></title>
    <url>%2F2015%2F07%2F04%2Fxy-problem%2F</url>
    <content type="text"><![CDATA[XY问题，一个对我来说比较新的词汇，但可能我们大家平时都遇到过这种问题。 对于“XY问题”，不同的人有不同的解释： 你想做X，但你认为Y是实现X最好的方法。你不问关于X的事，反而问起Y的事。 — 来自 Re: sequencial file naming by Abigail 你尝试去做X，但你想起了Y方案。于是，你开始问关于Y方案的事，完全不提X。问题是，也许会有更好的方案，但如果你不描述X是什么，我们根本无法出谋划策。— 来自 Re: How do I keep the command line from eating the backslashes? by revdiablo 有些人问如何去做Y，但他们实际是想做X。他们之所以问如何做Y，因为他们相信Y是实现X最好的方法。人们用各种的“试试这个”来给予帮助，而结果往往是“这不行，因为….”。这给我们提示，依赖环境的不同，你的问题可能会有其它更好的方案。— 来自 Re: Re: Re: Re: regex to validate e-mail addresses and phone numbers by Limbic~Region 在不理解更大的问题(上下文)X的情况下，去回答问题Y，往往完全无助于解决问题X。— 来自 &#x6d;&#49;&#x38;&#x7a;&#x74;&#53;&#109;&#117;&#113;&#x39;&#x2e;&#102;&#115;&#x66;&#x5f;&#x2d;&#x5f;&#x40;&#104;&#97;&#x6c;&#x66;&#100;&#111;&#109;&#101;&#46;&#x68;&#111;&#108;&#x64;&#x69;&#x74;&#46;&#x63;&#x6f;&#x6d; by merlyn 也叫做“过早下结论”：有疑问的人希望能解决一些阐述的并不清楚的问题X，他们断定Y是解决方案的一个要素，于是他们就询问如何实现Y。— from &#80;&#x69;&#x6e;&#101;&#x2e;&#71;&#72;&#80;&#x2e;&#52;&#46;&#x32;&#x31;&#x2e;&#48;&#x30;&#48;&#x39;&#x30;&#54;&#x31;&#x32;&#49;&#48;&#x35;&#55;&#48;&#x2e;&#56;&#x38;&#48;&#48;&#x2d;&#x31;&#x30;&#x30;&#x30;&#x30;&#48;&#x40;&#x68;&#x70;&#112;&#108;&#x75;&#x73;&#x30;&#x33;&#46;&#99;&#x65;&#x72;&#x6e;&#x2e;&#x63;&#104; by Alan J. Flavell XY问题是指，当你需要做X时，你认为可以用Y来实现X，于是你问如何做Y，而你实际应该做的是说明你的X问题是什么。也许会有一个比Y更好的Z解决方案，但如果X没有被说出来，没有人能提出更好的建议。— 来自 &#x73;&#x6c;&#114;&#x6e;&#x38;&#x39;&#x75;&#109;&#56;&#106;&#x2e;&#53;&#x67;&#57;&#46;&#116;&#x61;&#x64;&#x6d;&#x63;&#64;&#109;&#x61;&#x67;&#x6e;&#97;&#46;&#109;&#101;&#116;&#x72;&#x6f;&#110;&#101;&#x74;&#x2e;&#99;&#111;&#109; by Tad McClellan 当有人来问如何做一些傻事时，我真的不知道如何去做。我只能照实回答，说我可不要告诉别人如何做傻事….. 但是，一旦我这样做了，人们就会蹦到我面前自作聪明。这种事情经常发生。(“别呀，帮帮这个可怜的人吧，如果你知道他们真的需要知道如何做，你干嘛不告诉他们呢？”) . . . 另一方面，我可以从另一个层面上回答他们，给他们一个更好的方案，但这种执教也许会让他们脸上不好看。如果他们接受倒好，如果不接受，你会很伤心看到自己的努力和好建议被忽略。同样，人们会蹦到你面前指责你没有直接回答他们的问题。（“谁要你告诉他该怎么做了，你只要回答他的问题就行了。”） . . . 我想这种两种回答方式生活中都经常会有。但也许没有一种回答会得到好结果。— 来自 &#54;&#108;&#x6e;&#x62;&#x37;&#x30;&#36;&#x6c;&#99;&#x74;&#x24;&#49;&#64;&#109;&#x6f;&#110;&#x65;&#116;&#46;&#x6f;&#x70;&#x2e;&#x6e;&#x65;&#x74; by MJD 部分内容引用自外刊IT评论]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的UUID]]></title>
    <url>%2F2015%2F06%2F02%2Fpython%E4%B8%AD%E7%9A%84UUID%2F</url>
    <content type="text"><![CDATA[简介（维基百科） 通用唯一识别码（英语：Universally Unique Identifier，简称UUID）是一种软件建构的标准，亦为开放软件基金会组织在分散式计算环境领域的一部份。UUID的目的，是让分散式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指定。如此一来，每个人都可以建立不与其它人冲突的UUID。在这样的情况下，就不需考虑资料库建立时的名称重复问题。目前最广泛应用的UUID，是微软公司的全局唯一标识符（GUID），而其他重要的应用，则有Linux ext2/ext3档案系统、LUKS加密分区、GNOME、KDE、Mac OS X等等。另外我们也可以在e2fsprogs套件中的UUID函式库找到实现。[3] 定义 :UUID是由一组32位数的16进位数字所构成，是故UUID理论上的总数为1632=2128，约等于3.4 x 1038。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完，，它保证对在同一时空中的所有机器都是唯一的（重复机率请参考随机UUID的重复机率）。 算法 uuid1()——基于时间戳由MAC地址、当前时间戳、随机数生成。可以保证全球范围内的唯一性，但MAC的使用同时带来安全性问题，局域网中可以使用IP来代替MAC。 uuid2()——基于分布式计算环境DCE（Python中没有这个函数）算法与uuid1相同，不同的是把时间戳的前4位置换为POSIX的UID。实际中很少用到该方法。 uuid3()——基于名字的MD5散列值通过计算名字和命名空间的MD5散列值得到，保证了同一命名空间中不同名字的唯一性，和不同命名空间的唯一性，但同一命名空间的同一名字生成相同的uuid。 uuid4()——基于随机数由伪随机数得到，有一定的重复概率，该概率可以计算出来。 uuid5()——基于名字的SHA-1散列值算法与uuid3相同，不同的是使用 Secure Hash Algorithm 1 算法 在python中在生成UUIDimport uuid后即可使用示例代码12345import uuiduuid.uuid1()uuid.uuid3(namespace, name)uuid.uuid4()uuid.uuid5(namespace, name) 参考 http://zh.wikipedia.org/zh-hans/%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%A0%81https://docs.python.org/2/library/uuid.html]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>UUID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache Rewrite]]></title>
    <url>%2F2015%2F05%2F18%2FApache-Rewrite%2F</url>
    <content type="text"><![CDATA[本文是对今天使用Apache的Rewrite技术做一个简单的记录。 Apache的rewrite模块，提供了一个基于规则的重写(rewrite,也许译为重构更为合适)引擎，来实时重写发送到Apache的请求URL。因功能极其强大，被称为URL重写的“瑞士军刀”。 这个模块使用一个基于正则表达式解析器开发的重写引擎，根据web管理员定义的规则来实时(on the fly)重写请求URL。它支持任意数目的重写规则，以及附加到一条规则上的任意数目的规则条件，从而提供了一套非常灵活和功能强大的URL处理机制。 URL处理操作的实施与否，依赖于各种各样的条件检查，如检查服务器变量、环境变量、HTTP头字段、时间戳的值，甚至外部数据库的检索结果。这个模块可 以在服务器范围内(http.conf)、目录范围内(.htaccess)或请求串(query-string)的一部分处理有关的URL。重写的结果 URL，可以指向一个站内的处理程序、指向站外的重定向或者一个站内的代理。与灵活和功能强大相随的是设置的复杂。 更新历史2015年05月18日 - 初稿 开启模块在http.conf中找到1# LoadModule rewrite_module modules/mod_rewrite.so 取消注释 定义规则在http.conf中加入下列代码（如果启用了httpd-vhosts.conf，请在httpd-vhosts.conf里做配置）12345&lt;IfModule rewrite_module&gt; RewriteEngine on RewriteCond %&#123;HTTP_HOST&#125; ^www.a.com [NC] RewriteRule ^/(.*) http://www.b.com/$1 [R=301,l]&lt;IfModule&gt; RewriteCond义重写发生的条件，在一条RewriteRule指令前面可能会有一条或多条RewriteCond指令，只有当自身的模板(pattern)匹配成功且这些条件也满足时规则才被应用于当前URL处理，上面代码的NC：不区分大小写RewriteRule满足^/(.*)此规则的所有URL都重定向到http://www.b.com/$1，$1使用前面(.*)匹配后的字符填充 所以前面的规则就是的最终效果是访问www.a.com的所以页面都会被重定向到www.b.com相应路径下的页面 参考 http://blog.chinaunix.net/uid-20639775-id-154471.htmlhttp://man.lupaworld.com/content/manage/Apache2.2_chinese_manual/mod/mod_rewrite.htmlhttp://httpd.apache.org/docs/current/mod/mod_rewrite.html]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>重定向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Android Chrome以app形式打开网站]]></title>
    <url>%2F2015%2F05%2F11%2Fchrome-add-to-homescreen%2F</url>
    <content type="text"><![CDATA[前面一篇文章我讲到了在UC网站可以以app形式打开，其实在Android Chrome浏览器上也支持此功能。 添加配置文件在网站根目录添加manifest.json，并进行相应配置1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; "name": "iblogc", "icons": [ &#123; "src": "launcher-icon-0-75x.png", "sizes": "36x36", "type": "image/png", "density": "0.75" &#125;, &#123; "src": "launcher-icon-1x.png", "sizes": "48x48", "type": "image/png", "density": "1.0" &#125;, &#123; "src": "launcher-icon-1-5x.png", "sizes": "72x72", "type": "image/png", "density": "1.5" &#125;, &#123; "src": "launcher-icon-2x.png", "sizes": "96x96", "type": "image/png", "density": "2.0" &#125;, &#123; "src": "launcher-icon-3x.png", "sizes": "144x144", "type": "image/png", "density": "3.0" &#125;, &#123; "src": "launcher-icon-4x.png", "sizes": "192x192", "type": "image/png", "density": "4.0" &#125; ], "start_url": "index.html", "display": "standalone", "orientation": "portrait"&#125; 在网站公用头部引入配置文件1&lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot;&gt; 查看效果在Android使用Chrome打开网站，点击memu，选择“添加到主屏幕”选项，点击就可以添加到主屏幕了，步骤及显示效果截图如下：PS:地址栏是不是不见了,看着像app而不是网页 扩展ios的safari也有此功能，因手头无ios设备测试不了，所以内容不写了，大家可以参考此文章http://www.prower.cn/technic/2314 参考资料 https://developer.chrome.com/multidevice/android/installtohomescreen]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UC和QQ浏览器私有META]]></title>
    <url>%2F2015%2F05%2F06%2FUC%E5%92%8CQQ%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A7%81%E6%9C%89META%2F</url>
    <content type="text"><![CDATA[什么是META META是HTML语言中的一个标签，也称作元标记。 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。 标签位于文档的头部，不包含任何内容， 标签的属性定义了与文档相关联的名称/值对。 UC的私有META屏幕方向强制横屏/强制竖屏1&lt;meta name=&quot;screen-orientation&quot; content=&quot;landscape/portrait&quot;&gt; 全屏1&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt; xhtml适应屏幕排版默认值为uc-fitscreen=no，即不启用此功能，此时浏览器的缩放行为与标准一致。当设置为uc-fitscreen=yes，则当进行缩放操作时，仅放大图片和文字等页面元素，但不放大屏幕宽度，从而避免了左右滚动条的产生。 1&lt;meta name=&quot;viewport&quot; content=&quot;uc-fitscreen=yes&quot;/&gt; 排版模式Uc浏览器提供两种排版模式，分别是适屏模式及标准模式，其中适屏模式简化了一些页面的处理，使得页面内容更适合进行页面阅读、节省流量及响应更快，而标准模式则能按照标准规范对页面进行排版及渲染。通过新定义的标签及js api接口，可以让网页设计者执行决定采用何种排版方式向用户展现页面。1&lt;meta name=&quot;layoutmode&quot; content=&quot;fitscreen/standard&quot; /&gt; 夜间模式允许进入夜间模式/禁止进入夜间模式1&lt;meta name=&quot;nightmode&quot; content=&quot;enable/disable&quot;/&gt; 强制显示图片，不受浏览器无图设置影响1&lt;meta name=&quot;imagemode&quot; content=&quot;force&quot;/&gt; 应用模式默认将全屏，禁止长按菜单，禁止手势，标准排版1&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;/&gt; QQ浏览器的私有META屏幕方向强制横屏/强制竖屏/自动（默认）1&lt;meta name=&quot;x5-orientation&quot; content=&quot;landscape/portrait/auto&quot;/&gt; 全屏强制全屏/跟随浏览器（默认）1&lt;meta name="x5-fullscreen" content="true/auto"/&gt; 页面模式普通浏览模式（默认）/网页应用模式（定制工具栏，全屏显示）1&lt;meta name="x5-page-mode" content="default/app"/&gt; 参考资料 http://www.uc.cn/business/developer/http://open.mb.qq.com/doc?id=1201#_1]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>meta</tag>
        <tag>浏览器</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu安装Android Studio出现错unable to run mksdcard sdk tool]]></title>
    <url>%2F2015%2F03%2F28%2Fubuntu%E5%AE%89%E8%A3%85android-studio%E5%87%BA%E7%8E%B0%E9%94%99unable-to-run-mksdcard-sdk-tool%2F</url>
    <content type="text"><![CDATA[错误信息：unable to run mksdcard sdk tool原因：缺少库文件解决方法：sudo apt-get install lib32z1 lib32ncurses5 lib32bz2-1.0 lib32stdc++6]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu安装JDK8]]></title>
    <url>%2F2015%2F03%2F28%2Fubuntu%E5%AE%89%E8%A3%85JDK8%2F</url>
    <content type="text"><![CDATA[下载JDK8到oracle网站下载JDK8 解压安装12345sudo tar xzvf jdk-8u40-linux-x64.tar.gzmkdir -p /usr/lib/jvmsudo mv /usr/lib/jvm jdk1.8.0_40 /usr/lib/jvmcd /usr/lib/jvmsudo ln -s jdk1.8.0_40 java-8 配置环境变量添加PATH,CLASSPATH,JAVA_HOME环境变量gedit ~/.bashrc在打开的窗口里添加以下内容1234export JAVA_HOME=/usr/lib/jvm/java-8export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 保存退出，执行命令使配置生效source ~/.bashrc 配置默认JDK版本在有的系统中会预装OpenJDK，系统默认使用的是这个，而不是刚才装的。所以这一步是通知系统使用Oracle的JDK，非OpenJDK。1234sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-8/bin/java 300sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java-8/bin/javac 300sudo update-alternatives --config javasudo update-alternatives --config javac 验证是否成功java -version]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下运行shadowsocks客户端]]></title>
    <url>%2F2015%2F03%2F28%2Fubuntu%E8%BF%90%E8%A1%8Cshadowsocks%E5%AE%A2%E6%88%B7%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[Shadowsocks 是一个安全的socks5代理,用于保护网络流量,是一个开源项目,项目地址。 下载12sudo apt-get install python-pip python-m2cryptosudo pip install shadowsocks 配置sudo gedit /etc/shadowsocks/config.json1234567891011&#123; &quot;server&quot;:&quot;remote-shadowsocks-server-ip-addr&quot;, &quot;server_port&quot;:8883, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;abcdef&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;:false, &quot;workers&quot;:1&#125; 请根据实际情况配置 启动客户端sslocal -c /etc/shadowsocks.json 浏览器扩展Firefox可使用FoxyProxy StandardChrome可使用Proxy SwitchOmega配置请自行Google/百度]]></content>
      <categories>
        <category>优化辅助</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu更新NV显卡驱动]]></title>
    <url>%2F2015%2F03%2F27%2Fubuntu%E6%9B%B4%E6%96%B0NV%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[昨天在笔记本上新安装了ubuntu14.04LTS，顺便更新了下NV驱动，这里做下记录。 下载驱动首页在http://www.geforce.cn/drivers选择相应的显卡型号下载对应的驱动，下载完成后重命令为NVIDIA.run 关闭X server输入sudo /etc/init.d/gdm stop或sudo /etc/init.d/lightdm stop停止X server，这时桌面会消失，按Ctrl+Alt+F1进入文本模式 安装驱动进入驱动所在文件夹，执行sudo sh NVIDIA.run，安装驱动过程中会有几次对话框需要确认。 启动GDMsudo /etc/init.d/gdm start或sudo /etc/init.d/lightdm start 重启电脑sudo reboot 这样NV的驱动就安装好了。]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用ngrok配置微信公众号本地开发环境（ADSL屏蔽80端口问题）]]></title>
    <url>%2F2015%2F02%2F04%2F%E4%BD%BF%E7%94%A8ngrok%E9%85%8D%E7%BD%AE%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%EF%BC%88ADSL%E5%B1%8F%E8%94%BD80%E7%AB%AF%E5%8F%A3%E9%97%AE%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[更新记录2016-03-04 更新教程2015-09-16 添加旧版软件下载2015-02-04 初稿 鉴于国内大部分ADSL屏蔽80端口，而微信公众号开发只支持80端口，所以在本地开发测试微信公众号就是一个问题了，这里我们可以使用软件ngrok来解决这个问题。 配置步骤1. 注册ngrok账号注册成功后拿到授权码auth token，使用ngrok时并不强制用户注册，但注册后会附加更多功能(如自定义二级域名)； 2. 下载ngrok，解压；3. 启动方式一:让本地的‘http://127.0.0.1:80’ 可以让外网访问1ngrok http 80 ngrok会随机分配一个二级域名，可直接通过外网可通过http://xxxx.tunnel.mobi来访问本机的http://127.0.0.1:80网站 方式二：使用配置文件启动:在ngrok.exe目录下执行命令（不带尖括号），生成配置文件（配置文件会在C:\Users\用户名/.ngrok2/ngrok.yml下「windows」）1ngrok authtoken &lt;you authtoken&gt; 修改配置文件，可配置多个tunnel（注意，配置文件是yaml格式，冒号后面如果还有内容需要加空格）1234567891011121314151617181920authtoken:&lt;you authtoken&gt;tunnels: # 自定义隧道名 iblogc: #本地服务端口 addr: 4000 # 用于http/https里的身份认证 #auth: &quot;username:password&quot; proto: http # 二级域名，如果运行提示重复，换一个就行 subdomain: iblogc django: addr: 8000 auth: &quot;abc:123456&quot; proto: http subdomain: django weixin: addr: 80 proto: http subdomain: weixin 现在执行1ngrok start iblogc 试试，如果你设置的的二级域名没有被占用的话，那么就会启动成功，否则请更换一个二级域重试。http://iblogc.ngrok.io https://iblogc.ngrok.io 协议均可以访问。ngrok-start-iblogc.png) 你也可以同时启动两个tunnel1ngrok start iblogc django weixin ngrok-start-iblogc-django-weixin.png) 因为我的django tunnel配置文件里添加了auth配置所以访问http://django.ngrok.io需要输入用户名密码。ngrok-auth.png) 假设weixin就是我本地跑在80端口的微信项目，现在就可以在微信公众平台「开发者中心」可以使用weixin.ngrok.com进行配置了，所有发向此域名的请求都会转发到你的本地127.0.0.1:80上。 4. 查看详细信息如果想查看详细的请求信息可以在浏览器里打开http://127.0.0.1:4040查看详细信息nrok-web-interface.png) 5. 参考文档官方文档：https://ngrok.com/docs]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>微信公众号</tag>
        <tag>端口</tag>
        <tag>ngrok</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git命令使用指南]]></title>
    <url>%2F2015%2F01%2F16%2FGit%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[Git是软件开发人员在开发中常用的一种工具,是开发之利器。 Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。 工作流图示 命令配置 git config --global user.name &#39;Your Name&#39; 设置git提交显示的名字 git config --global user.email your_email@example.com 设置git提交显示的邮箱 git config --global alias.unstage &quot;reset HEAD&quot; 替换命令 git reset HEAD命令改为 git unstage ssh-keygen -t rsa -C your_email@example.com 生成SSH Key git config --global core.editor emacs 设置文件编辑器 git config --global merge.tool vimdiff 设置差异分析工具 git config --list 查看配置信息 简洁版初始化仓库git init 添加远程仓库git remote add &lt;自定义名字&gt; &lt;远程仓库url&gt; 给某个仓库名再添加另一个远程仓库url（可实现一次提交到两个远程仓库）git remote set-url --add &lt;自定义名字&gt; &lt;远程仓库url&gt; 更新项目git pull 合并分支到当前分支git merge &lt;分支名&gt; 创建标签git tag &lt;标签名字&gt; &lt;提交id前10位字符&gt; 可通过git log获取 获取loggit log 切换分支git checkout &lt;分支名&gt; 创建分支并切换过去git checkout -b &lt;分支名&gt; 删除分支git branch -D &lt;分支名&gt; 推送git push origin &lt;分支名/标签名&gt; 强制推送更新git push -f origin &lt;分支名/标签名&gt; 推送所有分支git push origin --all 推送所有标签git push origin --tags 撤消本地改动（新文件和提交到缓存区的改动，不受影响）git checkout -- &lt;目录&gt;&lt;文件名&gt; 撤消本地所有提交与改动假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它git fetch origingit reset --hard origin/master 其它命令 gitk 获取当前分支图形个界面 参数&lt;分支名&gt;: 获取某分支图形界面 参数=--all: 获取所有分支图形个界面 cat &lt;目录&gt;&lt;文件名&gt; 查看文件内容 详细版初始 git init 初始化仓库 ls 显示目录下文件及文件夹（不包含隐藏文件即名字前带点的） 参数-a显示目录下所有文件及文件夹 git clone &lt;url&gt; 克隆项目 提交 git add &lt;目录&gt;&lt;文件名&gt; 添加文件到版本库，可以多个文件一起添加，中间用空格隔开 git add * 或 git add . 添加所有文件到版本库 git status 查看项目当前状态，详细信息 参数-s: 显示简洁版 绿色表示已经提交的缓存区，红色表示在工作区未提交到缓存区的A新增 M修改 D删除 U冲突 R重命名？push会把绿色部分提交，红色部分不提交已有记录文件做过改动和新文件，需要git add git diff 查看整个项目里的文件改动情况（工作区和缓存区比较） 参数&lt;目录&gt;&lt;文件名&gt;: 查看单个文件改动情况（工作区和缓存区比较）-参数&lt;标签名&gt;: 查看自当前标签发布之后项目的改动情况 参数--cached: 查看整个项目里的文件改动情况（缓存区和本地仓库比较） 参数 HEAD: 查看整个项目里的文件改动情况（工作区和本地仓库比较） 参数--stat: 显示摘要，而非完整diff git commit: 提交到缓存 参数-m: 后面空格接提交信息 参数-a: 为所有已有记录文件执行git add（新添加文件还是需要手动git add） git reset HEAD 取消缓存已缓存的内容 参数&lt;目录&gt;&lt;文件名&gt;: 单个文件取消缓存已缓存内容 git rm &lt;目录&gt;&lt;文件名&gt;: 将文件从缓存区和硬盘上移除 参数--cached: 删除缓存中的文件，保留硬盘上的文件 git mv 不推荐用 git log 显示当前分支提交记录 参数--author=&lt;authorname&gt;: 只寻找某个特定作者的提交 参数--oneline: 显示简洁版 参数--oneline -&lt;数字N&gt;: 显示简洁版，显示最近N次提交的记录 参数--graph: 显示拓扑图（查看历史中什么时候出现了分支、合并） 参数--grep=&lt;关键字&gt;: 根据提交注释关键字过滤提交记录 Git 会对所有的 –grep 和 –author 参数作逻辑或。 如果你用 –grep 和 –author 时，想看的是某人写作的并且有某个特殊的注释内容的提交记录， 你需要加上 –all-match 选项。 在这些例子中，我会用上 –format 选项，这样我们就可以看到每个提交的作者是谁了。详细参考：Git参考手册:检查与比较 参数&lt;分支名&gt;:显示指定分支“可及”的提交记录 参数&lt;分支名1&gt; ^&lt;分支名1&gt;: 查看在分支1不在分支2中的提交记录 分支可以是本地的也可以是远端的 参数--decorate: 显示带tag的记录 参数-p: 显示每个提交引入的补丁 参数--stat: 显示每个提交引入的差值统计 其它参数 --since --before --until --after git log –since –before 根据日期过滤提交记录如果你要指定一个你感兴趣的日期范围以过滤你的提交，可以执行几个选项 —— 我用 –since 和 –before，但是你也可以用 –until 和 –after。 例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 –no-merges 选项以隐藏合并提交）Git参考手册:检查与比较： $ git log --oneline --before={3.weeks.ago} --after={2010-04-18} --no-merges 5469e2d Git 1.7.1-rc2 d43427d Documentation/remote-helpers: Fix typos and improve language 272a36b Fixup: Second argument may be any arbitrary string b6c8d2d Documentation/remote-helpers: Add invocation section 5ce4f4e Documentation/urls: Rewrite to accomodate transport::address 00b84e9 Documentation/remote-helpers: Rewrite description 03aa87e Documentation: Describe other situations where -z affects git diff 77bc694 rebase-interactive: silence warning when no commits rewritten 636db2c t3301: add tests to use --format=&quot;%N&quot; 分支 git branch列出当前项目的可用分支，并显示当前工作目录当前分支 参数&lt;分支名&gt;: 创建分支 git checkout &lt;分支名&gt; 切换到对应分支 参数-b 创建分支并立即切换到新分支 git merge &lt;分支名&gt; 合并指定分支到当前分支 标签 git tag 显示当前项目的标签 参数&lt;标签名&gt; 给某个历史记录打标签 参数-a: 添加注解 参数&lt;SHA&gt;: 提交id前n位字符，可通过git log获取，n位基于SHA唯一就行（建议5~7位） 远程 git remote 列出远端别名-参数-v: 列出远端别名及链接 一般一个别名会看到两个相同的链接（fetch和push）分别是获取和推送的链接-add &lt;仓库别名&gt; &lt;仓库链接&gt;: 为项目添加一个新的远端仓库 rm &lt;仓库别名&gt;: 为项目删除一个远端仓库只是本地删掉和远端仓库的链接，不会对远端仓库造成影响 git fetch 从远端仓库下载最新的分支与数据 git pull 从远端仓库下载最新数据，并尝试合并到当前分支 参数&lt;仓库别名&gt;: 从哪个仓库拉取更新，默认为origin git pull实际是先git fetch后git merge git push 推送更新 参数&lt;仓库别名&gt; &lt;分支名&gt;: 推送新分支与数据到某个远端仓库 参数&lt;仓库别名&gt; --all: 推送所有分支 参数&lt;仓库别名&gt; --tagsl: 推送所有标签 参考资料 Git 参考手册git - 简易指南]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pip常用命令]]></title>
    <url>%2F2015%2F01%2F01%2Fpip%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[列出已安装的包pip freeze or pip list 导出requirements.txtpip freeze &gt; &lt;目录&gt;/requirements.txt 安装包在线安装pip install &lt;包名&gt; 或 pip install -r requirements.txt 12345678# 安装1.9版本的djangopip install django==1.9# 安装版本号大于1.9的django，注意有引号pip install &quot;django&gt;1.9&quot;pip install &quot;django&gt;=1.9&quot;pip install &quot;django&lt;1.9&quot;pip install &quot;django&lt;=1.9&quot;pip install &quot;django&gt;&lt;1.9&quot; requirements.txt内容格式为： APScheduler==2.1.2 Django==1.5.4 MySQL-Connector-Python==2.0.1 MySQL-python==1.2.3 PIL==1.1.7 South==1.0.2 django-grappelli==2.6.3 django-pagination==1.0.7 安装本地安装包pip install &lt;目录&gt;/&lt;文件名&gt; 或 pip install --use-wheel --no-index --find-links=wheelhouse/ &lt;包名&gt; &lt;包名&gt;前有空格 可简写为 pip install --no-index -f=&lt;目录&gt;/ &lt;包名&gt; 卸载包pip uninstall &lt;包名&gt; 或 pip uninstall -r requirements.txt 升级包pip install -U &lt;包名&gt; 升级pippip install -U pip 显示包所在的目录pip show -f &lt;包名&gt; 搜索包pip search &lt;搜索关键字&gt; 查询可升级的包pip list -o 下载包而不安装 pip install &lt;包名&gt; -d &lt;目录&gt; 或 pip install -d &lt;目录&gt; -r requirements.txt 打包pip wheel &lt;包名&gt; 更换国内pypi镜像国内pypi镜像 豆瓣：https://pypi.douban.com/simple 中国科学技术大学：https://mirrors.ustc.edu.cn/pypi/web/simple/ 清华大学TUNA：https://pypi.tuna.tsinghua.edu.cn/simplehttps://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/ 指定单次安装源pip install &lt;包名&gt; -i http://pypi.v2ex.com/simple 指定全局安装源在unix和macos，配置文件为：$HOME/.pip/pip.conf在windows上，配置文件为：%HOME%\pip\pip.ini [global] timeout = 6000 index-url = http://pypi.douban.com/simple 参考资料 pip documentation]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>命令</tag>
        <tag>教程</tag>
        <tag>Python</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Virtualenv创建独立的Python运行环境]]></title>
    <url>%2F2015%2F01%2F01%2F%E4%BD%BF%E7%94%A8virtualenv%E5%88%9B%E5%BB%BA%E7%8B%AC%E7%AB%8B%E7%9A%84python%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[准备工作 python环境 pip 安装1pip install virtualenv 或1pip install https://github.com/pypa/virtualenv/tarball/develop 创建虚拟环境1virtualenv myVE 指定python解释器 1-p PYTHON_EXE, --python=PYTHON_EXE 创建虚拟环境时默认会自动安装setuptools和pip 不安装setuptool 1--no--setuptools 不安装pip 1--no--pip 更多Options请参考官方文档 启动虚拟环境 Mac OS 12cd myVEsource ./bin/activate Windows 12cd myVEscripts\activate 启动成功后可以在开头显示”(myVE)”，说明已经进入刚刚创建的虚拟环境了 退出1deactivate virtualenvwrapper安装 Virtaulenvwrapper是virtualenv的扩展包，用于更方便管理虚拟环境，它可以做： 将所有虚拟环境整合在一个目录下 管理（新增，删除，复制）虚拟环境 切换虚拟环境 1pip install virtualenvwrapper Windows下还需额外安装virtualenvwrapper-win1pip install virtualenvwrapper-win ubuntu需要将下面这句加入到~/.bashrc里面123if [ -f /usr/local/bin/virtualenvwrapper.sh ]; then source /usr/local/bin/virtualenvwrapper.shfi 加入后需要重启才能生效，如果想要立即生效，输入命令1source ~/.bashrc 常用命令部分命令在windows下无效 workon myEnv: 切换虚拟环境 mkvirtualenv: 新建工作环境 rmvirtualenv: 删除工作环境 cdproject: 切换到工程目录 workon/lsvirtualenv: 列出所有虚拟环境 deactivate: 退出虚拟环境 cpvirtualenv [source] [dest] 复制一份虚拟环境。 cdvirtualenv [subdir] 把当前工作目录设置为所在的环境目录。 cdsitepackages [subdir] 把当前工作目录设置为所在环境的sitepackages路径。 add2virtualenv [dir] [dir] 把指定的目录加入当前使用的环境的path中，这常使用于在多个project里面同时使用一个较大的库的情况。 toggleglobalsitepackages -q 控制当前的环境是否使用全局的sitepackages目录。 参考资料https://virtualenv.pypa.io/en/latest/ http://virtualenvwrapper.readthedocs.org/en/latest/ https://github.com/davidmarble/virtualenvwrapper-win]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Virtualenv</tag>
        <tag>virtualenvwrapper</tag>
        <tag>独立</tag>
        <tag>虚拟环境</tag>
        <tag>requirements</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电影《小黄人》中文预告片]]></title>
    <url>%2F2014%2F11%2F09%2F%E7%94%B5%E5%BD%B1%E3%80%8A%E5%B0%8F%E9%BB%84%E4%BA%BA%E3%80%8B%E4%B8%AD%E6%96%87%E9%A2%84%E5%91%8A%E7%89%87%2F</url>
    <content type="text"><![CDATA[导演: 凯尔·巴尔达 / 皮埃尔·科芬编剧: 布莱恩·林奇主演: 迈克尔·基顿 / 桑德拉·布洛克 / 乔恩·哈姆 / 凯蒂·米克松 / 真田广之 / 珍妮弗·桑德斯 / 皮埃尔·科芬 / 克里斯·雷纳德 / Dave Rosenbaum类型: 喜剧 / 动画 / 家庭制片国家/地区: 美国语言: 英语上映日期: 2015-07-10(美国)又名: 小黄人大电影豆瓣链接: 小黄人预告版:]]></content>
      <categories>
        <category>影视</category>
      </categories>
      <tags>
        <tag>电影</tag>
        <tag>小黄人</tag>
        <tag>预告片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages/GitCafe Pages绑定自定义域名]]></title>
    <url>%2F2014%2F11%2F09%2FGithub-Pages-Gitcafe-Pages%E7%BB%91%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[更新记录2015-01-01 更新 GitCafe-Page IP地址2014-11-09 初稿 虽然GitHub Pages和GitCafe Pages默认为每个用户分配了一个二级域名（GitHub为username.github.io或username.github.com,GitCafe为username.gitcafe.com），但如果你对这个二级域名不满意也可以申请一个自己的域名进行绑定。下面就说说GitHub和GitCafe的绑定过程。 准备工作 域名（例：iblogc.com） 一个GitHub Pages/GitCafe Pages GitHub 在repo目录下创建一个名为CNAME的文件（无后缀） 打开CNAME，在里面写入你要绑定的域名 1)如果你绑定的是二级域名，请在域名管理里添加一条CNAME记录，指向username.github.io或username.github.com 2)如果你绑定的是顶级域名，请在域名管理里添加一条A记录，指向103.245.222.133 请在域名管理里添加一条CNAME记录，指向username.github.io 等待生效 GitCafe 打开你自己的gitcafe pages项目， 进入 项目管理&gt;&gt;自定义域名，在这里添加你要绑定的域名就可以，比如我配置了顶级域名iblogc.com（当然也可以设置二级域名） QQ截图20141109181543.png) 在域名管理里添加一条CNAME记录，记录值为gitcafe.io，如果您的域名注册商不提供CNAME记录选项，请将A记录值修改为 207.226.141.135(IP地址截止2015-01-01有效，如失效，请以官方说明为准)。 等待生效]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>域名</tag>
        <tag>GitHub</tag>
        <tag>GitCafe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2014%2F09%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in trobuleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
